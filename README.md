# wikibinator203

U is a universal combinator, some combos GPU optimizable. A node is U or a pair of nodes (lambda call). Every node returns a node or never halts. These 3 edge types (L R EvalsTo) are a constant infinite size directed-graph. Any software fills graph in from partial pattern is AGI.

A kind of number. Build anything by drag-and-drop of a universal combinator (lambda). GPU. Streaming. Massively multiplayer. Peer to peer. Experimenting, TODO..A fork-editable multiverse of all possible streaming of all possible combos of lambda functions with shareable function ids for every possible function or "multiverse state" etc. universal function to build and run music tools, science tools, AI research, game worlds, etc, inside itself like a self-hosting-compiler, in a massively multiplayer decentralized way. Some basic parts work, or use earlier wikibinator106. For making massively-multiplayer browser or desktop apps, games, musical instruments, science tools, number crunching, security research, etc, a universal lambda function (combinator), GPU optimizable, javascript eval optimizable, 256 bit ids of merkle forest, each lambda has 2 lambda childs and all paths lead to the universal lambda.

 (Lambda [a b c d] {(T []) (T backward ) (T is) (P d) (P c) (P b) (P a)} these are some words) --> [backward is words some are these]

Made for everyone, but for now its hard to use... Programmers and mathematicians, try Wikibinator203 at https://humanai.net/wikibinator/ The universal function works. Over the next few years I plan to turn this into an endless infinite dimensional space where many people build and play together, sharing lambdas by 256 bit ID or QRCode.

LICENSE SUMMARY: Its basically, do whatever you want but nobody owns the lambdas, and that in the evilbit=true namespace all possible bits are allowed, including evil bits (even if its virus, ransomware, etc), as its an antivirus quarantine, and in the evilbit=false namespace it works like the normal internet. DETAILS: <a href=https://github.com/benrayfield/wikibinator203/blob/main/LICENSE>LICENSE</a>

<img src=https://raw.githubusercontent.com/benrayfield/wikibinator203/main/pics/2022-7-22_unicodeAlmostWorking.png>
<img src=https://raw.githubusercontent.com/benrayfield/wikibinator203/main/pics/wikibinator203_2022-6-24-305p_mouseDraggedToLookBetter.png>
<img src=https://raw.githubusercontent.com/benrayfield/wikibinator203/main/pics/TestWikibinator203VM.html.png>

To see it working, look at this browser console output (from the html file) <a href=https://raw.githubusercontent.com/benrayfield/wikibinator203/main/BrowserConsoleLogOutput.txt>https://raw.githubusercontent.com/benrayfield/wikibinator203/main/BrowserConsoleLogOutput.txt</a>

Planned features
* everything can work by drag-and-drop of lambda onto lambda to find/create lambda or writing code, and all that can be shared online instantly at gaming-low-lag or local only.
* use lambdas instead of bits, as the tiny pieces the internet is made of. Using any 2 lambdas together (call one on the other) finds or creates a lambda. Lambdas can be anything such as a word, picture, sound, game, tool, or something that draws a mustache on any picture you drag it to. Anything.
* 32 bit 2d voxels (which just paint the screen, can do 3d or 50 dimensions or fractals, whatever) for 1024x1024 resolution, 12 bit color ( <img src=https://upload.wikimedia.org/wikipedia/commons/4/47/RGB_12bits_palette.png></img> and <img src=https://upload.wikimedia.org/wikipedia/commons/5/56/RGB_12bits_palette_sample_image.png></img> are 2 12-bit-color pics from https://en.wikipedia.org/wiki/List_of_monochrome_and_RGB_color_formats#12-bit_RGB vs 24-bit <img src=https://upload.wikimedia.org/wikipedia/commons/d/d7/RGB_24bits_palette_sample_image.jpg></img> and 12 bit is just precise enough not to be cartoony but you can see its weaker than normal coloring), at 60+ fps, and every voxel, and every bit in every voxel, is a lambda, with quicksave and quickload of whole game state, of any games we make, including calling lambdas on games to make more games. You could, for example, be playing a game, then drag that video/sound window to your friends, and a tiny fraction of a second later (if its not too big, or if you have some lambdas in common already cached) they can be playing it, and they have the ability to build new things with it and share with others or back to you etc, as its just another lambda. Similarly, multiplayer games will work by such immutable snapshots of lambdas doing video/sound/gamepads/etc. Its turing complete so you could literally be inside a game and gradually build it into a completely different kind of game or science tool or musical instrument etc. Its not limited to these kind of graphics/sound but will come with that as a basic demo, something to get started with. Simple demo should also include, using these 32 bit 2d voxels, a 1 teraflop view of 3d mandelbrot fractal, optimized using GPU.js, with ability to edit and share it in realtime.
* Its not dumbed down. In theory, can build real science tools that change the world, or games, musical instruments, or anything, by drag-and-drop of lambdas you can send and receive in realtime. They're a kind of number, so nothing anyone does with a lambda changes that lambda, just finds or builds more lambdas with it.
* AI (artificial intelligence), that is made of lambdas, writes code for new AIs, using lambdas for both code and data, sometimes from scratch and sometimes using given parts of AIs such as learning algorithms that other AIs or parts of them (or recursive use of itsself) may combine, making use of the recursive time and memory limits to avoid infinite loops etc.
* median forking latency of 1 microsecond.
* some parts GPU optimizable. Memory mapping.
* no central control. In theory there will be a variety of realtime interoperable wikibinator203 VMs that all run the same universal lambda math and may sometimes choose to turing-complete-challenge-response eachother for lambda called on lambda returns what lambda. Accusations against specific lambdas (for just existing, since they dont do anything except find/create lambdas and are a kind of number) can in theory be responded to by "did put it in antivirus quarantine", since there is a whole area of the system that runs in an antivirus quarantine so thats a no-op, but the other "normal" area, which works by the same math, is the part such accusations may be directed at.
* exactly repeatable calculations in strictest mode.
* can run evil code (virus, ransomware, some AI generated code, etc) safely in a sandbox. All code is sandboxed. You are warned not to give execute permission, believe, or obey anything in the evil_bit=true area unless you can verify it on your own such as by a trusted network of digital signatures or math proofs or other evidence etc.
* does not need execute permission.
* Sandbox can be private or shared across many computers.
* every lambda call returns a lambda or gives up after recursive limits of time and memory.
* zero-knowledge-proof allows global sync from everywhere to everywhere near lightspeed.
* turing-complete load-balancing, and turing-complete-challenge-response of lambda called on lambda finds/creates what lambda.
* unique 256 bit number (or 512 bit for extra security) for each lambda, other than if there was a secureHash-collision.
* optimization to throw sound processing code faster than the speed of sound from one computer to a nearby computer which formal-verifies, compiles, and runs that code in time to hear the sound arrive and think about and respond.

First app running on this will maybe be musical instruments similar to https://en.wikipedia.org/wiki/Pure_Data that can be shared in realtime to build more musical instruments with and so on, and this "proof of concept" will be able to scale to millions of simultaneous instruments being played and generated and evolved, and every bit, every tiny part of a sound vibration, is a lambda.



Working on the programming language syntax.
Its going to be intuitive (see Fibonacci theoretical example farther below) and work with coding or drag-and-drop, but first I have to get through this low level stuff. I've got lambda toString working for basic stuff, and vm.eval(wikibinator203CodeString) is nearly working for basics...



If you type this on browser console:
''+Seq(Infcur(L)(R)(Seq(T(Seq(Pair)))))
It returns this:
'_[L R _,_Pair]'

Infcur(U)(U)(Infcur(T)) = [U U [T]]

Pair(Pair(S)(S))(R) = (Pair (Pair S S) R)

T(T(Seq(S(S(T)(Pair))(T)))) = ,,_{T Pair T}

S(S(T)(S(L)(R)))(T) aka {T {L R} T} = {T {L R} T}

S(S(T)(T))(T)  aka {T T T} = {T T T}


''+Seq(Infcur(L)(R)(Seq(T(Seq(Pair)))))
Wikibinator203VM.js:4500 tokens: ["[]"]
Wikibinator203VM.js:4511 viewing.tokens.push builtInName L
Wikibinator203VM.js:4500 tokens: ["L"]
Wikibinator203VM.js:4124 Evaling l=[] r=L
Wikibinator203VM.js:4511 viewing.tokens.push builtInName L
Wikibinator203VM.js:4500 tokens: ["[","L","]"]
Wikibinator203VM.js:4511 viewing.tokens.push builtInName R
Wikibinator203VM.js:4500 tokens: ["R"]
Wikibinator203VM.js:4124 Evaling l=[L] r=R
Wikibinator203VM.js:4511 viewing.tokens.push builtInName Seq
Wikibinator203VM.js:4500 tokens: ["Seq"]
Wikibinator203VM.js:4511 viewing.tokens.push builtInName Pair
Wikibinator203VM.js:4500 tokens: ["Pair"]
Wikibinator203VM.js:4124 Evaling l=Seq r=Pair
Wikibinator203VM.js:4511 viewing.tokens.push builtInName T
Wikibinator203VM.js:4500 tokens: ["T"]
Wikibinator203VM.js:4511 viewing.tokens.push builtInName Pair
Wikibinator203VM.js:4500 tokens: ["_","Pair"]
Wikibinator203VM.js:4124 Evaling l=T r=_Pair
Wikibinator203VM.js:4511 viewing.tokens.push builtInName Seq
Wikibinator203VM.js:4500 tokens: ["Seq"]
Wikibinator203VM.js:4511 viewing.tokens.push builtInName Pair
Wikibinator203VM.js:4500 tokens: [",","_","Pair"]
Wikibinator203VM.js:4124 Evaling l=Seq r=,_Pair
Wikibinator203VM.js:4511 viewing.tokens.push builtInName L
Wikibinator203VM.js:4554 [ pushed space
Wikibinator203VM.js:4511 viewing.tokens.push builtInName R
Wikibinator203VM.js:4500 tokens: ["[","L"," ","R","]"]
Wikibinator203VM.js:4511 viewing.tokens.push builtInName Pair
Wikibinator203VM.js:4500 tokens: ["_",",","_","Pair"]
Wikibinator203VM.js:4124 Evaling l=[L R] r=_,_Pair
Wikibinator203VM.js:4511 viewing.tokens.push builtInName Seq
Wikibinator203VM.js:4500 tokens: ["Seq"]
Wikibinator203VM.js:4511 viewing.tokens.push builtInName L
Wikibinator203VM.js:4554 [ pushed space
Wikibinator203VM.js:4511 viewing.tokens.push builtInName R
Wikibinator203VM.js:4554 [ pushed space
Wikibinator203VM.js:4511 viewing.tokens.push builtInName Pair
Wikibinator203VM.js:4500 tokens: ["[","L"," ","R"," ","_",",","_","Pair","]"]
Wikibinator203VM.js:4124 Evaling l=Seq r=[L R _,_Pair]
Wikibinator203VM.js:4511 viewing.tokens.push builtInName L
Wikibinator203VM.js:4554 [ pushed space
Wikibinator203VM.js:4511 viewing.tokens.push builtInName R
Wikibinator203VM.js:4554 [ pushed space
Wikibinator203VM.js:4511 viewing.tokens.push builtInName Pair
Wikibinator203VM.js:4500 tokens: ["_","[","L"," ","R"," ","_",",","_","Pair","]"]
'_[L R _,_Pair]'



OLDER browser console output...


''+u(u)

wikibinator203.js:1404 Evaling l=u r=u

'op10'

t(u)

wikibinator203.js:1404 Evaling l=t r=u

ƒ (param){
			
			//TODO test the code NODE.evaler(NODE.lam,param) which should do this.
			//TODO evaler, so can put various optimizations per node. chain of evalers with evaler.on defining which i…
			
''+t(u)

wikibinator203.js:1404 Evaling l=t r=u

't(u)'

''+pair

'pair'

''+pair(s)(t)

wikibinator203.js:1404 Evaling l=pair r=s

wikibinator203.js:1404 Evaling l=pair(s) r=t

'pair(s)(t)'

''+pair(s)(l)

wikibinator203.js:1404 Evaling l=pair r=s

wikibinator203.js:1404 Evaling l=pair(s) r=l

'pair(s)(l)'

''+pair(s)(l)(t)

wikibinator203.js:1404 Evaling l=pair r=s

wikibinator203.js:1404 Evaling l=pair(s) r=l

wikibinator203.js:1404 Evaling l=pair(s)(l) r=t

wikibinator203.js:1404 Evaling l=t r=l

wikibinator203.js:1404 Evaling l=t(l) r=s

'l'

''+pair(s)(l)(f)

wikibinator203.js:1404 Evaling l=pair r=s

wikibinator203.js:1404 Evaling l=pair(s) r=l

wikibinator203.js:1404 Evaling l=pair(s)(l) r=f

wikibinator203.js:1404 Evaling l=f r=l

wikibinator203.js:1404 Evaling l=f(l) r=s

's'


If you want the universal lambda that works, go to <a href=https://github.com/benrayfield/wikibinator106>wikibinator106</a>, for now. This different universal lambda function will hopefully be working soon with some simple games and demos people can play together, as actual javascript lambdas that implement the universal lambda math.

This system is neutral about everything except that all interactions through it are voluntary between individuals without needing permission of any third party, and that nobody owns the infinite number of lambdas which are all possible 2-way forest nodes where all paths lead to the universal lambda, which can do all possible things of finite information. It is net-neutral to the extreme, does not care what lambdas (or bits in some of them) mean (other than when a lambda is called on a lambda it finds/creates the mathematically correct lambda), except if someone is searching for a thing that thing is preferred. That may lead to conflicts with those who try to enforce non-neutral things on others, and for that they should stay on the evil_bit=false side and let neutrality (which contains both good and evil, but is safely sandboxed) exist on the evil_bit=true side, 2 namespaces of the same system differing by just 1 bit in the ids.




Code will be like this, or see wikibinator106 log output for real example of earlier version.

You start with 1 javascript variable, which can build all possible things...

const wikibinator203 = (function(){ ...this software goes here... })();

let u = wikibinator203; //shorter name

let uu = u(u);

let opcode2 = uu;

let opcode3 = u(uu);

let opcode4 = u(u)(u);

let opcode5 = u(u)(uu);

...

let opcode128 = u(u)(u)(u)(u)(u)(u)(u);

...

let opcode254 = u(uu)(uu)(uu)(uu)(uu)(uu)(u);

let opcode255 = u(uu)(uu)(uu)(uu)(uu)(uu)(uu);

These opcodes are various common lambdas such as s, church-true church-false church-pair, ways of using GPU, if/else, loops, etc.
All opcodes are known at 7 params. Further params use the opcode, such as the s lambda takes 3 more params.

...or you might skip some stuff by using lambdas other people give you...

Most control-flow is done using the s lambda aka Lx.Ly.Lz.xz(yz) and the church-true aka t lambda aka Lx.Ly.x, as in SKI-Calculus.

Syntax:

{a b} means (s a b)

{a b c} means {{a b} c} aka (s (s a b) c), aka in javascript this code will actually work: s(s(a)(b))(c).

,a means (t a), often used like ({,+ getX getY} treemapZ) which evals to (+ (getX treemapZ) (getY treemapZ)).

Syntax: abc.def<<ghi<5>>>

<<>> gets from something like what {} means in javascript, a map of string to thing.

<> gets from a Float64Array. These 2 things are used in small blocks of javascript-like code
  that compiles to javascript but blocks access to Float64Array.buffer etc so it can guarantee
  that all lambda calls halt within chosen limits of memory and time that can be tightened recursively on stack.
  
[a b c] means (infcur a b c). Infcur takes infinity params aka never evals, so its a kind of list.

?varABC is (getVar varABC)

Any string without whitespace that starts with a lowercase letter is a string literal, so varABC is 'varABC'. If capital, its a #Name like (...)#Fibonacci and (Fibonacci 3) of a constant function. There are no variables in a 2-way-forest of universal function, other than constants that act like variables in some ways of using them statelessly/immutably.
  
(func param)->return caching is used in lambda, but NOT in For/While/DoWhile/streaming/etc which is more for number crunching, thats sometimes done from one lambda call to the next. Lambda will look something like this (TODO)...
..
<code>
(
	Lambda
	[x]
	{
		,IfElse
		{,Lt ?x ,3}
		,1
		{,+ {Recur1 ?x} {Recur1 {,- ?x ,1}}}
	}
)#Fibonacci
..
(Fibonacci 1) -> 1
(Fibonacci 2) -> 1
(Fibonacci 3) -> 2
(Fibonacci 4) -> 3
(Fibonacci 5) -> 5
(Fibonacci 6) -> 8
</code>
  
All lambdas have 2 child lambdas, even the u/universalLambda has the 2 childs of identityFunction and itself.
The left child called on the right child evals to the parent so its like a quine that way, if its halted,
else it might eval to something else whose left child called on its right child its itself cuz it is halted.

Everything can work by drag-and-drop or typing code. Everything is a lambda and can be shared in realtime or choose not to copy things into public,
but once something gets into public, as nobody owns the generated lambdas, it may be copied freely by many, so dont go looking to take it back.

This does not normally do proof-of-work, and instead uses hashing only for making unique ids of lambdas. This is not a blockchain even though it has the merkle forest data structure in common with them, and only lazyevals that.

The new js file ends this way, QUOTE...
	return u; //the universal function
})();
console.log('Script ended. wikibinator203 = '+wikibinator203+' which is the universal combinator/lambda you can build anything with. Nobody owns the lambdas made of combos of calling the universal lambda on itself (such as wikibinator203(wikibinator203)(wikibinator203(wikibinator203)))='+wikibinator203(wikibinator203)(wikibinator203(wikibinator203))+', and see license for details about that. By design, there are an infinite number of possible variants of https://en.wikipedia.org/wiki/Technological_singularity which wikibinator203 may generate (or it may do other simpler things) but only as, kind of, lazy-evals. It is by design neutral. It does not tend to do that on its own (but even a broken clock is right 1, 2, or 3 times a day depending on daylight savings, so whatever may already have execute permission on your computer (including unknown hackers, or some generated lambda may, if you view it as a conversation or as text etc, ask you to give it more permissions, so like they say about email, dont run any files received)...) - may not execute anything ever for any reason, as it has "recursively-tightenable-higher-on-stack permissions system" (search comments in this file or earlier versions of it) whose max level is sandbox (though an opensource fork of it could give execute or higher permissions similarly as long as its stateless, thats probably not a good idea). If a "singularity" is to happen, then it should support https://en.wikipedia.org/wiki/Breakpoint and, as motivation to it or to more generally any user(s), this system should (TODO verify) in practice be able to EFFICIENTLY run a debugger of a debugger of a debugger of a debugger (like a Hypervisor/VMWare/etc inside a Hypervisor/VMWare/etc inside... except those kinds of VMs are far to complex to do efficiently in this system, as this is more of a nanokernel or smaller/simpler), just a few levels deep, as compute is the bottleneck there, but in abstract math can do that to any finite depth, even in the middle of a "optimization to throw sound processing code faster than the speed of sound from one computer to a nearby computer which formal-verifies, compiles, and runs that code in time to hear the sound arrive and think about and respond.".');


Here's some of the opcodes (that arent all coded yet), which the addOp function in the vm in Wikibinator203.js defines, and you see this in the browser console output:
Wikibinator203VM.js:3805 Add op Op1111110 o8=126 curriesLeft=Op1111110 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
Wikibinator203VM.js:3805 Add op Op1111111 o8=127 curriesLeft=Op1111111 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
Wikibinator203VM.js:3805 Add op F o8=128 curriesLeft=2 description: the church-false lambda aka Î»y.Î»z.z. (f u) is identityFunc. To keep closing the quine loop simple, identityFunc is (u u u u u u u u u) aka (f u), but technically (u u u u u u u u anything) is also an identityFunc since (f anything x)->x. (l u)->(u u u u u u u u u). (r u)->u. (l u (r u))->u, the same way (l anythingX (r anythingX))->anythingX forall halted lambda anythingX.
Wikibinator203VM.js:3805 Add op T o8=129 curriesLeft=2 description: the church-true lambda and the k lambda of SKI-Calculus, aka Î»y.Î»z.y
Wikibinator203VM.js:3805 Add op Bit0 o8=130 curriesLeft=248 description: complete binary tree is made of pow(2,cbtHeight) number of bit0 and bit1, evals at each curry, and counts rawCurriesLeft down to store (log2 of) cbt size
Wikibinator203VM.js:3805 Add op Bit1 o8=131 curriesLeft=248 description: see bit0
Wikibinator203VM.js:3805 Add op L o8=132 curriesLeft=1 description: get left/func child. Forall x, (l x (r x)) equals x, including that (l u) is identityFunc and (r u) is u.
Wikibinator203VM.js:3805 Add op R o8=133 curriesLeft=get right/param child. Forall x, (l x (r x)) equals x, including that (l u) is identityFunc and (r u) is u. description: undefined
Wikibinator203VM.js:3805 Add op Isleaf o8=134 curriesLeft=1 description: returns t or f of is its param u aka the universal lambda
Wikibinator203VM.js:3805 Add op IsClean o8=135 curriesLeft=1 description: the 2x2 kinds of clean/dirty/etc. exists only on stack. only with both isClean and isAllowSinTanhSqrtRoundoffEtc at once, is it deterministic. todo reverse order aka call it !isDirty instead of isClean?
Wikibinator203VM.js:3805 Add op IsAllowSinTanhSqrtRoundoffEtc o8=136 curriesLeft=1 description: the 2x2 kinds of clean/dirty/etc. exists only on stack. only with both isClean and isAllowSinTanhSqrtRoundoffEtc at once, is it deterministic. todo reverse order?
Wikibinator203VM.js:3805 Add op Lambda o8=137 curriesLeft=2 description: FIXME this will take varsize list [(streamGet varName) (streamGet otherVar) ...] and a funcBody (or is funcBody before that param) then that varsize list (up to max around 250-something params (or is it 120-something params?) then call funcBody similaar to described below (except maybe use [allParamsExceptLast lastParam] instead of (pair allParamsExceptLast lastParam)) FIXME TODO the streamGet op should work on that datastruct that funcBody gets as param, so (streamGet otherVar [allParamsExceptLast lastParam])-> val of otherVar in the param list of lambda op. OLD... Takes just funcBody and 1 more param, but using opOneMoreParam (the only vararg op) with a (lambda...) as its param, can have up to (around, TODO) undefined params including that funcBody is 8th param of u. (lambda funcBody ?? a b ??? c d e) -> (funcBody (pair (lambda funcBody ?? a b ??? c d) e)). It might be, Im trying to make it consistent, that funcBody is always param 8 in lambda and varargAx. (opOneMoreParam aVarName aLambda ...moreParams...).
Wikibinator203VM.js:3805 Add op GetVarFn o8=138 curriesLeft=2 description: theres 4 things in stream [x valXLambda valXDoubleRaw valXDoubleArrayRaw y val val val z val val val ...], 3 of which are vals. FIXME choose 3 prefix chars such as ?x _x /x. Rewrite this comment... so, ddee? would be a syntax for (getnamedparam "ddee").
Wikibinator203VM.js:3805 Add op GetVarDouble o8=139 curriesLeft=2 description: theres 4 things in stream [x valXLambda valXDoubleRaw valXDoubleArrayRaw y val val val z val val val ...], 3 of which are vals. FIXME choose 3 prefix chars such as ?x _x /x. Rewrite this comment... so, ddee? would be a syntax for (getnamedparam "ddee").
Wikibinator203VM.js:3805 Add op GetVarDoubles o8=140 curriesLeft=2 description: theres 4 things in stream [x valXLambda valXDoubleRaw valXDoubleArrayRaw y val val val z val val val ...], 3 of which are vals. FIXME choose 3 prefix chars such as ?x _x /x. Rewrite this comment... so, ddee? would be a syntax for (getnamedparam "ddee").
Wikibinator203VM.js:3805 Add op VarargAx o8=141 curriesLeft=2 description: FIXME varargAx has strange behaviors about curriesLeft and verifying it and halted vs evaling. Its 2 params at first but after that it keeps extending it by 1 more param, after verifying the last param and choosing to be halted or eval at each next param. That design might change the number of params to simplify things, so careful in building on this op yet. I set it to 2 params so that after the first 7 params it waits until 9 params to eval, and after that it evals on every next param.
Wikibinator203VM.js:3805 Add op S o8=142 curriesLeft=3 description: For control-flow. the s lambda of SKI-Calculus, aka Î»x.Î»y.Î»z.xz(yz)
Wikibinator203VM.js:3805 Add op Pair o8=143 curriesLeft=3 description: the church-pair lambda aka Î»x.Î»y.Î»z.zxy
Wikibinator203VM.js:3805 Add op Infcur o8=144 curriesLeft=255 description: Infcur aka (Infcur) is []. (Infcur x) is [x]. (Infcur x y z) is [x y z]. Like a linkedlist but not made of pairs. just keep calling it on more params and it will be instantly halted.
Wikibinator203VM.js:3805 Add op ObVal o8=145 curriesLeft=2 description: used with opmut and _[...] etc.
Wikibinator203VM.js:3805 Add op ObCbt o8=146 curriesLeft=2 description: used with opmut and _[...] etc.
Wikibinator203VM.js:3805 Add op ObKeyVal o8=147 curriesLeft=3 description: used with opmut and _[...] etc.
Wikibinator203VM.js:3805 Add op OpmutOuter o8=148 curriesLeft=2 description: (opmutOuter treeOfJavascriptlikeCode param), and treeOfJavascriptlikeCode can call opmutInner which is like opmutOuter except it doesnt restart the mutable state, and each opmutInner may be compiled (to evaler) separately so you can reuse different combos of them without recompiling each, just recompiling (or not) the opmutOuter andOr multiple levels of opmutInner in opmutInner. A usecase for this is puredata-like pieces of musical instruments that can be combined and shared in realtime across internet.
Wikibinator203VM.js:3805 Add op OpmutInner o8=149 curriesLeft=2 description: See opmutOuter. Starts at a Mut inside the one opmutOuter can reach, so its up to the outer opmuts if that Mut contains pointers to Muts it otherwise wouldnt be able to access.
Wikibinator203VM.js:3805 Add op StackIsAllowstackTimestackMem o8=150 curriesLeft=1 description: reads a certain bit (stackIsAllowstackTimestackMem) from top of stack, part of the recursively-tightenable-higher-on-stack permissions system
Wikibinator203VM.js:3805 Add op StackIsAllowNondetRoundoff o8=151 curriesLeft=1 description: reads a certain bit (stackIsAllowNondetRoundoff) from top of stack, part of the recursively-tightenable-higher-on-stack permissions system
Wikibinator203VM.js:3805 Add op StackIsAllowMutableWrapperLambdaAndSolve o8=152 curriesLeft=1 description: reads a certain bit (stackIsAllowMutableWrapperLambdaAndSolve) from top of stack, part of the recursively-tightenable-higher-on-stack permissions system
Wikibinator203VM.js:3805 Add op StackIsAllowAx o8=153 curriesLeft=1 description: reads a certain bit (stackIsAllowAx) from top of stack, part of the recursively-tightenable-higher-on-stack permissions system
Wikibinator203VM.js:3805 Add op IsCbt o8=154 curriesLeft=1 description: returns T or F, is the param a cbt aka complete binary tree of bit0 and bit1
Wikibinator203VM.js:3805 Add op ContainsAxConstraint o8=155 curriesLeft=1 description: returns t or f, does the param contain anything that implies any lambda call has halted aka may require infinite time and memory (the simplest way, though sometimes it can be done as finite) to verify
Wikibinator203VM.js:3805 Add op Dplusraw o8=156 curriesLeft=2 description: raw means just the bits, not wrapped in a typeval. add to doubles/float64s to get a float64, or if in that op that allows reduced precision to float32 (such as in gpu.js) then that, but the result is still abstractly a double, just has less precision, and in gpujs would still be float32s during middle calculations.
Wikibinator203VM.js:3805 Add op StreamGet o8=157 curriesLeft=2 description: FIXME theres 3 vals per key, not just 1. Merge this with GetVarFn GetVarDouble and GetVarDoubles. OLD... Reads a streaming map. Uses an infcur/[...] as a map, thats a stream-appendable (by forkEdit, still immutable) list of key val key val. It does linear search in the simplest implementation but opmut is being replaced by streamGet and streamPut etc which will have a Node.evaler optimization to compile combos of streamGet and streamPut and For While + * / Math.sin Math.exp etc... compile that to javascript code (still cant escape sandbox or cause infinite loops outside the stackTime stackMem etd (gas*) system, and in some cases compile it to GPU (such as using GPU.js or Lazycl). (streamGet keyB [keyB otherVal keyA valA keyB valB keyC valC])->valB, or ->u if there is no valB. [...] means (infcur ...). From the right end, looks left until finds the given key, and returns the val for it, or if reaches infcur before finding the key, then returns u. [...] is variable size. ([...] x)->[... x], so do that twice to append a key and val. Same key can be updated multiple times, statelessly. Equality of keys is by content/forestShape (see equals op). Vals arent checked for equality so you can use lazyDedup such as wrapping a large Float64Array or Float32Array or Int32Array (maybe only of powOf2 size or maybe bize and blobFrom and blobTo var can handle non-powOf2?) in a Node.
Wikibinator203VM.js:3805 Add op StreamPut o8=158 curriesLeft=2 description: Writes a streaming map. See streamGet. (streamPut keyB someVal [keyA valA keyB valB keyA anotherVal])->[keyA valA keyB valB keyA anotherVal keyB someVal]
Wikibinator203VM.js:3805 Add op StreamPack o8=159 curriesLeft=1 description: ForkEdits a [...] to only have the last val for each key. You would do this after writing a bunch of key/vals to it, each key written 1 to many times. For example, just a simple loop of a var from 0 to a million would create a [] of size 2 million, but streamPack it during that or at the end and its just size 2. When Evaler optimized it wont even create the [...] in the middle steps. (streamPack [keyA valA keyB valB keyA anotherVal])->[keyB valB keyA anotherVal].
Wikibinator203VM.js:3805 Add op Get32BitsInCbt o8=160 curriesLeft=2 description: (get32BitsInCbt cbtOf32BitBlocks cbt32Index)->cbt32Val
Wikibinator203VM.js:3805 Add op Put32BitsInCbt o8=161 curriesLeft=3 description: (put32BitsInCbt cbtOf32BitBlocks cbt32Index cbt32Val)->forkEdited_cbtOf32BitBlocks
Wikibinator203VM.js:3805 Add op Equals o8=162 curriesLeft=2 description: By content/forestShape of 2 params. This op could be derived using s, t, l, r, and isLeaf. implementationDetailOfThePrototypeVM(((If a node doesnt contain a blob such as Int32Array (which is just an optimization of bit0 and bit1 ops) then its id64 (Node.idA and Node.idB, together are id64, and blobFrom and blobTo would both be 0 in that case, which is normally id128) is its unique id in that VM. Maybe there will be a range in that id64 to mean blobFrom and blobTo are both 0 aka does not contain a blob.))).
Wikibinator203VM.js:3805 Add op StreamWhile o8=163 curriesLeft=3 description: (streamWhile condition loopBody stream) is like, if you wrote it in javascript: while(condition(stream)) stream = loopBody(stream); return stream;
Wikibinator203VM.js:3805 Add op StreamDoWhile o8=164 curriesLeft=3 description: (streamDoWhile loopBody condition stream) is like, if you wrote it in javascript: do{ stream = loopBody(stream); }while(condition(stream)); return stream; 
Wikibinator203VM.js:3805 Add op StreamFor o8=165 curriesLeft=5 description: (streamFor start condition afterLoopBody loopBody stream) is like, if you wrote it in javascript: for(stream = start(stream); condition(stream); stream = afterLoopBody(stream)) stream = loopBody(stream); return stream;
Wikibinator203VM.js:3805 Add op IfElse o8=166 curriesLeft=4 description: (ifElse condition ifTrue ifFalse state) is like, if you wrote it in javascript: ((condition(state) ? ifTrue : ifFalse)(state)).
Wikibinator203VM.js:3805 Add op If o8=167 curriesLeft=3 description: (if condition ifTrue state) is like, if you wrote it in javascript: (condition(state) ? ifTrue(state) : state).
Wikibinator203VM.js:3805 Add op GetSalt128 o8=168 curriesLeft=1 description: (getSalt128 ignore)->the cbt128 of salt thats at top of stack aka 3-way-lambda-call of salt128 func and param.
Wikibinator203VM.js:3805 Add op WithSalt128 o8=169 curriesLeft=3 description: (withSalt128 cbt128 func param)-> (func param) except with that cbt128 pushed onto the salt stack. During that, getSalt128 will get that cbt128.
Wikibinator203VM.js:3805 Add op WithSalt128TransformedBy o8=170 curriesLeft=1 description: (withSalt128TransformedBy funcOf128BitsTo128Bits func param)-> same as (withSalt128 (funcOf128BitsTo128Bits (getSalt128 u)) func param).
Wikibinator203VM.js:3805 Add op SolveRecog o8=171 curriesLeft=1 description: (solveRecog x) -> any y where (x y) halts, preferring those that use less compute resources (stackTime stackMem etc) but THIS IS NONDETERMINISTIC so can only be used while stackIsAllowMutableWrapperLambdaAndSolve is true on stack. This is for bit what solveFloat64 is for double/float64.
Wikibinator203VM.js:3805 Add op SolveFloat64 o8=172 curriesLeft=1 description: (solveFloat64 x) -> any y where (x y)->float64 (todo is the float64 the raw 64 bits or is it wrapped in a typeval or a typevalDouble etc?), where the float64 is positive, and the higher the better. Requiring positive makes it able to emulate solveRecog. The higher the better, makes it a goal function. Like solveRecog, THIS IS NONDETERMINISTIC so can only be used while stackIsAllowMutableWrapperLambdaAndSolve is true on stack.
Wikibinator203VM.js:3805 Add op Bize31 o8=173 curriesLeft=1 description: (bize31 x) -> cbt32, the low 31 bits of the index of the last (op) bit1, if its a cbt, else 0 if its not a cbt or does not contain any bit1. Bize means bitstring size (in bits). Max bitstring size is around 2^247-1 bits (todo find exact number).
Wikibinator203VM.js:3805 Add op Bize53 o8=174 curriesLeft=1 description: (bize53 x) -> cbt64, the low 53 (so it can be stored in a double) bits of bize. See bize32 comment for what is bize in general.
Wikibinator203VM.js:3805 Add op Bize256 o8=175 curriesLeft=1 description: (bize256 x) -> cbt256. See bize31 comment for what is bize in general. This always fits in a 256 bit literal that is its own id.
Wikibinator203VM.js:3805 Add op LambdaParamsList o8=176 curriesLeft=1 description: From any number of curries (such as waiting on 3 more params in this: (Lambda FuncBody [w x y z] 100), or from the (LazyEval (Lambda... allParamsExceptLast) lastParam) if it has all its params which FuncBody is called on), gets the whole [w x y z], or gets [] if its not 1 of those datastructs. [...] is infcur syntax.
Wikibinator203VM.js:3805 Add op LambdaParamsStream o8=177 curriesLeft=1 description: FIXME this should return a [(Mut...) (Mut...) (Mut...)]. FIXME see comments at top of this js file, about [...] of "[cbtNotNecessarilyDeduped doubleThatIsOrWillBeDeduped fnThatIsOrWillBeDeduped fnNotNecessarilyDeduped fnAsKeyThatIsOrWillBeDeduped]" as snapshot of Mut. Used with (Lambda FuncBody [x y z] valX valY valZ) -> (FuncBody (LazyEval (opLambda FuncBody [x y z] valX valY) valZ)). Returns [x valXLambda valXDoubleRaw valXDoubleArrayRaw y val val val z val val val], in blocks of those 4 things, which is used with Opmut/For/While/etc.
Wikibinator203VM.js:3805 Add op Seq o8=178 curriesLeft=2 description: The _ in (_[a b c] x) means ((Seq [a b c]) x) which does (c (b (a x))), for any vararg in the [].
Wikibinator203VM.js:3805 Add op HasMoreThan7Params o8=179 curriesLeft=1 description: op is known at 7 params, so thats sometimes used as end of a list, especially in an infcur list.
Wikibinator203VM.js:3805 Add op Op180ReservedForFutureExpansionAndInfloopsForNow o8=180 curriesLeft=undefined description: undefined
Wikibinator203VM.js:3805 Add op Op181ReservedForFutureExpansionAndInfloopsForNow o8=181 curriesLeft=undefined description: undefined

The rest of this readme got too long and disorganized, will rewrite soon.
