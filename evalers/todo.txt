todo in mutjseval...
Do I want the ability to cache and eval js funcs in general? I could add a vm.ops.JsEval opcode and a vm.mask_* bit for permission to call it, though would have to make room for that in vm.Node.header (int).
Also, within same run of the VM, cache the names used in this optimization, if they differ from node.n.id(). prefix+(state.ids++) making such names would not make them differ if those are utf8 strings of those chars. i havent hooked it into fns yet.
I want a way to call this optimization without wikib. It should be testable on its own, and generate graphics fast enuf for augmentedballs/webcam/canvas. Maybe separately callable???
Make vm.Node (vm.lambdize wraps a vm.Node in a js function) check normally get wrapped in fn as immutable so might need separate func.). A mut in IfElse/For/etc is normally a treemap or a key or val inside it, so any fn could be a snapshot of it. Its the "state" param in some opcodes, used statelessly.
Need opmutGroupId in case mut optimization calls fn on fn that does another mut optimization recursively. so the names must be unique across all mut calls. put opmutGroupId in the names of mutable objects but not in the names of immutable objects.'
Should I use a certain range of doubles as vm.Node localIds, instead of having the 4x32 bits for that? Could use 36 bits for whichObject and 17 bits for 1 2 4 8 ... 65536 bytes, a binheap index. or 28 bits for which object and 25 bits of binheap so 1..16mB per object. Could put that in the second highest exponent, so it rarely happens by chance that a computed double overlaps that. It would have to be checked for of course. If 28 bits for which object, it would only be able to make 256m objects before have to recompute that (related to garbage collection maybe). That might happen every 256/.4 seconds so about 11 minutes, or if i optimize it better or as faster computers are made, that could get down to 1 second maybe in the next 10 years. Branching will always be expensive. that it would make 256 million objects, not counting viewing parts of them in powOf2 aligned subranges of array of 1..16mB arrays. I could adjust Number.prototype so that (3.45)[2.9993] -> 334234.32, for example, and does a function call when GET in it. Or I could do that with string. etc. but maybe not efficiently cuz would have to adjust its prototype to store stuff somewhere else.
Should i do 31or32 bit whichObject and 16bit binheapindex and use doubles as ids?
Should I use strings as localids? Should i use alot of Math.max(param,maxPossibleId) if id range is in the big magnitude negatives? Or put it in the big magnitude positives? If make it bigger than float32 can do, then gpujs wont ever generate it so can optimize that way. music code (double,double)->double might run slower if have to do alot of Math.max(param,maxPossibleId).
If use string as localid then hashing (see vm.cp(fn,fn)) would be slower cuz of getting 16 bits from each char, or 6 bits if base64 etc. base58 would be even slower per char. hex faster per char but maybe slower overall cuz theres more chars. But it would be faster in using objects as js{} keys. Could get 64 bits from a double. theres code in vm to do that already, using overlapping Float64Array.buffer and Int32Array.buffer. careful of nonnormed doubles.
Might be worth it to simplify things by making all localIds be js strings.
Id like my objects, including vm.Node/fn, vm.Mut or new Float32Array(342342), 2.34, etc, to have names i can use longterm, maybe keep them in a database or versions of a big text file, maybe share them among 50 players in an online game, but not scaling bigger than that. Might be best to only share globalId256 across multiplayer/computers, but within 1 computer at least, need optimization of objects that arent deduped, that have mutable contents and cycles in map in map in map..., mutable arrays, etc.
Maybe in general define names as whichNamespace+'.'+nameInThatNamespace or something like that. whichNamespace might be just something random you make up or maybe your ed25519 publickey or a dataurl... not sure. I dont want to confuse my names with someone elses names, in case they appear as hardcoded literals in opensource code or something. But for efficiency, whichNamespace would not normally be written with the name. Dont confuse with use of '.' in wikib code.
Names should not overlap any of the fields in js Number or js String or js {}'s prototype or js Float32Array etc.
js toString function should return name.if its param is a vm.Mut (or whatever this mutjseval evaler creates) and modify that and return part of that (a js{} js[] Float32Array or a double etc, except FIXME those would 
Should it be a constant length string local id? 8 base64 chars would be 48 bits. 12 chars would be that plus 24 bits of binheap indexing.
so could longterm store these ids with array size of 1..16mB each (first 8 chars would be idA and idB).
Example 12 chars: YWRmZ2RmZ2Fz.
Should these ids, which might be 12 or 16 bytes (undecided what size around that), include objects in local-computer black-box stateful systems such as WebAudioAPI nodes, Uiint8Array's from canvas objects? Streaming from microhpones and to speakers, for example.