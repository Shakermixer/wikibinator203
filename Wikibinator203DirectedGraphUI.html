<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<script src="Wikibinator203VM.js" charset="UTF-8"></script>
<script>
//This script is under the Wikibinator203 license.

//directed graph ui...

let U = Wikibinator203; //the universal function
let vm = Wikibinator203().vm;
//let S = vm.ops.S;
//let T = vm.ops.T;
//let F = vm.ops.F;
//let Pair = vm.ops.Pair;
if(!vm) throw 'No vm';
for(let op in vm.ops){
	if(window[op]) throw 'Already have var window.'+op;
	window[op] = vm.ops[op];
	console.log('Created var for opcode as lambda: window.'+op);
}

var cssPositionType = 'absolute';

var randInt = n=>Math.floor(Math.random()*n);

var between = (min, val, max)=>Math.max(min, Math.min(val, max));

var betweenInt = (min, val, max)=>Math.floor(Math.max(min, Math.min(val, max)));

var asByte = num=>betweenInt(0,num,255);

var colorStr = function(redFraction, greenFraction, blueFraction){
	let r = asByte(redFraction*256);
	let g = asByte(greenFraction*256);
	let b = asByte(blueFraction*256);
	let s = '000000'+(r*65536+g*256+b).toString(16);
	return '#'+s.substring(s.length-6);
};

var randColorStr = ()=>colorStr(.45+.55*Math.random(), .45+.55*Math.random(), .45+.55*Math.random());

var Dob = (parentDob,tag,optionalInnerHtml)=>{
	let ret = document.createElement(tag);
	if(parentDob) parentDob.appendChild(ret);
	if(optionalInnerHtml) ret.innerHTML = optionalInnerHtml;
	return ret;
};

var typeToPic = {
	//TODO ls: which is oftel (R (L x)) for any x, and is other times just (L x),
	//depending how it would normally e displayed in code strings (see "syntax type" syty etc).
	l: 'greenSawTooth.png', //left child
	r: 'blueSawTooth.png', //right child
	s: 'sSawTooth.png', //sCurryList aka {...} syntax. {a b c} means (S (S a b) c) aka {{a b} c}.
	e: 'redSawTooth.png', //evalsto
};

//from and to are UINOdes. type is (TODO choose an edge
var UIEdge = function(from, type, to){
	
	//dom object, a div whose background shows direction like saw teeth, and css is used to make it a line at an angle between 2 UINodes.
	this.dob = null;

	this.from = from;
	this.type = type;
	this.from.outs[type] = this;
	this.to = to;
	this.display();
};

var angle = 0;

var edgeBackgroundOffset = 0;

var displayUiedges = true;
//var displayUiedges = false;

UIEdge.prototype.display = function(){
	if(!displayUiedges) return;
	if(!this.dob){
		let parentDob = mainDiv;
		//let parentDob = document.body;
		//let parentDob = this.from.dob;
		//if(!parentDob) throw 'UINode hasnt displayed yet so cant display edge from it, this='+this;
	
		//this.dob = Dob(parentDob,'div'); //put edge's div it in the div of the UINode its from.
		this.dob = Dob(parentDob,'div');
		this.dob.style.position = cssPositionType;
		//this.dob.style.height = '50px';
		//this.dob.style.width = '13px';
		//this.dob.style.width = '5px';
		//this.dob.style.width = '2px';
		//this.dob.style.height = '154px';
		//TODO css for angle
		//this.dob.style['background-color'] = randColorStr();
		this.dob.style.background = 'url('+typeToPic[this.type]+')';
		this.dob.style['z-index'] = -1;
	}
	

	
	//https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix
	let diffY = this.to.pos[0]-this.from.pos[0];
	let diffX = this.to.pos[1]-this.from.pos[1];
	let diffLen = Math.hypot(diffY,diffX);
	this.dob.style.height = '2px';
	this.dob.style.width = Math.ceil(diffLen)+'px';
	let normY = between(-1,diffY/diffLen,1);
	let normX = between(-1,diffX/diffLen,1);
	//let angle = Math.asin(normY);
	
	
	let a = normX;
	let b = normY;
	let c = -normY;
	let d = normX;
	
	
	//let a = 1/Math.sqrt(2), b = 0, c = 0, d = 1/Math.sqrt(2);
	//let a = 1, b = 0, c = 0, d = 1;
	//let a = Math.sin(angle), b = Math.cos(angle), c = -Math.cos(angle), d = Math.sin(angle);
	//this.dob.style.width = '90px';
	//let a = -1, b = 0, c = 0, d = -1;
	//let a = 5, b = 0, c = 0, d = 5;
	
	/*let a = 1;
	let b = 2.1;//let b = .3;
	let c = 0; //let c = -.1;
	let d = 1;
	*/
	//let tx = 0;
	//let ty = 0;
	
	//midpoint cuz [style.transform matrix or matrix3d] uses center of dob as (0,0,0) instead of top left corner as usual in html and as usual in opengl and other 3d frameworks.
	//let ty = this.from.pos[0]+diffY/2;
	//let tx = this.from.pos[1]+diffX/2;
	let ty = (this.from.pos[0]+this.to.pos[0])/2;
	let tx = (this.from.pos[1]+this.to.pos[1])/2;
	//let ty = this.from.pos[0];
	//let tx = this.from.pos[1];
	//let ty = this.to.pos[0];
	//let tx = this.to.pos[1];
	tx -= diffLen/2; //without this, it appears to the right of where it should be, in some strange coordinate system that rotates around the middle of a div, or something.
	
	
	//a = diffY*.01;
	//d = diffX*.01;
	
	//if(this.type == 'l'){ ty += 20; tx += 20; }
	//if(this.type == 'r'){ ty += 35; tx += 35; }
	//if(this.type == 'e'){ ty += 50; tx += 50; }
	this.dob.style.transform = 'matrix('+a+','+b+','+c+','+d+','+tx+','+ty+')';
	//this.dob.style.transform = 'matrix3d('+a+','+b+',0,0,  '+c+','+d+',0,0,  0,0,1,0,  '+tx+','+ty+',0,1)';
	
	this.dob.style['background-position'] = edgeBackgroundOffset+'px';
	
};

var Rnd = ()=>Math.random();

//var countTemp = 0;

let countUINodes = 0;

var repelMult = 3;
var farAttractMult = 125;
var speedDecay = .85;
var pushParentAboveChild = 22.3;
var pushLToBeLeftOfRRegardlessOfHeight = 30;

var getEdges = function(){
	let ret = [];
	for(let node of nodes){
		for(let edgeType in node.outs){
			let edge = node.outs[edgeType];
			ret.push(edge);
		}
	}
	return ret;
};

//from is l. to is r. todo rename those vars.
var potentialEnergyOfLR = (yFrom, xFrom, sizeFrom, yTo, xTo, sizeTo)=>{
	let en = 0;
	//let dy = yTo-yFrom;
	let dx = xTo-xFrom;
	let repelDist = sizeFrom+sizeTo;
	//let distSq = dy*dy + dx*dx;
	//let dist = Math.sqrt(distSq);
	if(dx < repelDist){
		let diff = repelDist-dx;
		en += diff*diff*pushLToBeLeftOfRRegardlessOfHeight;
	}
	return en;
};

var potentialEnergyOfPairOfNodesForRepel = (yFrom, xFrom, sizeFrom, yTo, xTo, sizeTo)=>{
	let en = 0;
	let dy = yTo-yFrom;
	let dx = xTo-xFrom;
	//let distSq = dy*dy + dx*dx;
	//let dist = Math.sqrt(distSq);
	let dist = Math.hypot(dy,dx);
	let repelDist = sizeFrom+sizeTo;
	if(dist < repelDist){
		let diff = repelDist-dist;
		en += diff*diff*repelMult;
	}
	return en;
};

/** This is used for spring-like positioning of uinodes on screen.
y and x are screen positions. nodeTypes are what kind of icon it is, such as evaling vs this kind of list [...] etc.
edgeType is 'l' for left child, 'r' for right child, 'e' for evals to what, etc.
Sizes are approx radius, even though radius doesnt describe a rectangle well, it will tend to give things more or less space on screen.
FIXME should this be called even if there is no edge? cuz they could overlap otherwise.
*/
var potentialEnergyOfEdge = (yFrom, xFrom, sizeFrom, fromType, edgeType, toType, yTo, xTo, sizeTo)=>{
	let en = 0;
	let dy = yTo-yFrom;
	let dx = xTo-xFrom;
	//let distSq = dy*dy + dx*dx;
	//let dist = Math.sqrt(distSq);
	let dist = Math.hypot(dy,dx);
	let repelDist = sizeFrom+sizeTo;
	/*do this in potentialEnergyOfPairOfNodesForRepel instead...
	if(dist < repelDist){
		let diff = repelDist-dist;
		en += diff*diff*repelMult;
	}*/
	if(pushParentAboveChild){ //can set pushParentAboveChild to 0 as an optimiziation to not do this code
		let diff = dy-repelDist;
		if(diff < 0){
			//child is near same height as parent or above parent.
			//move child down and parent up, so the forest shape is more intuitively displayed.
			en += diff*diff*pushParentAboveChild;
		}
	}
	//TODO optimize, only do this part if edgeType is a kind that exists (have 1 kind that means "noEdge", but use a shorter name?)
	en += dist*farAttractMult; //attract, but weaker than repelDist
	//en += dist*dist*farAttractMult; //attract, but weaker than repelDist
	return en;
};

const dims = 2;

var doPhysics = dt=>{
	let edges = getEdges();
	for(let edge of edges){ //edges attract and in some cases TODO try to be at certain angles and distances relative to eachother.
		updateUinodeAccelsForEdge(dt,edge);
	}
	for(let i=1; i<nodes.length; i++){ //repel all pairs of nodes if closer than sum of their nodeA.size+nodeB.size
		let ni = nodes[i];
		for(let j=0; j<i; j++){ //all pairs of nodes, excluding self and self, and not again for the reverse pair
			let nj = nodes[j];
			updateUinodeAccelsForRepelPairIfTooClose(dt, ni, nj);
			//updateUinodeAccelsForRepelPairIfTooClose(ni.pos[0], ni.pos[1], ni.size, nj.pos[0], nj.pos[1], nj.size);
		}
	}
	for(let node of nodes){
		//forces between childs of each node (all edge types) such as node.l and node.r
		//but TODO also the other edge types
		updateUinodeAccelsBetweenChildsOfNode(dt,node);
	}
	let minY = 0; //FIXME leave some room at top for textareas of code, buttons, etc.
	let maxY = 1200; //FIXME what should this be?
	let minX = 0;
	let maxX = 900; //FIXME get from screen
	for(let node of nodes){ //dont let nodes get too far from main area of screen.
		let newY = between(minY, node.pos[0], maxY);
		let newX = between(minX, node.pos[1], maxX);
		if(node.pos[0] != newY){
			node.pos[0] = newY;
			node.vel[0] = 0; //if hit a wall, set velocity to 0
		}
		if(node.pos[1] != newX){
			node.pos[1] = newX;
			node.vel[1] = 0; //if hit a wall, set velocity to 0
		}
	}
	let speedMul = between(0,1-dt*speedDecay,1);
	for(let node of nodes){
		for(let d=0; d<dims; d++){
			node.vel[d] += node.accel[d]; //FIXME if put *dt here then dont *dt in updateUinodeAccelsForEdge.
			node.accel[d] = 0;
			node.vel[d] *= speedMul;
			if(draggingNode == node){
				node.vel[d] = 0; //dont move node by physics while mouse is dragging it
			}
			node.pos[d] += dt*node.vel[d];
		}
	}
};

/*
//potential-energy, to be measured +dy +dx and +0, for each end, and take derivatives so know which direction to accelerate,
//then put the x and y positions back.
var edgeEnergyFunc = edge=>{
	return Math.random(); //FIXME
};

var updateUinodeAccels = function(){
	TODO loop over all edges
};
*/

const epsilon = .000001;

var updateUinodeAccelsBetweenChildsOfNode = function(dt,node){
	let halfEpsilon = epsilon/2;
	let l = node.outs.l;
	let r = node.outs.r;
	if(l && r){
		l = l.to; //change from edge to node
		r = r.to;
		let enAtHere = potentialEnergyOfLR(l.pos[0], l.pos[1], l.size, r.pos[0], r.pos[1], r.size);
		let enAtHerePlusDy = potentialEnergyOfLR(l.pos[1]+halfEpsilon, l.pos[1], l.size, r.pos[0]-halfEpsilon, r.pos[1], r.size);
		let enAtHerePlusDx = potentialEnergyOfLR(l.pos[0], l.pos[1]+halfEpsilon, l.size, r.pos[0], r.pos[1]-halfEpsilon, r.size);
		let dEnergyOverDy = (enAtHerePlusDy-enAtHere)/epsilon;
		let dEnergyOverDx = (enAtHerePlusDx-enAtHere)/epsilon;
		let ay = dt*dEnergyOverDy/2; //FIXME is /2 right?
		let ax = dt*dEnergyOverDx/2;
		l.accel[0] -= ay;
		l.accel[1] -= ax;
		r.accel[0] += ay; //FIXME did i get the += and -= backward?
		r.accel[1] += ax;
	}
};

var updateUinodeAccelsForRepelPairIfTooClose = function(dt, nodeA, nodeB){
	let halfEpsilon = epsilon/2;
	let fr = nodeA;
	let to = nodeB;
	let enAtHere = potentialEnergyOfPairOfNodesForRepel(fr.pos[0], fr.pos[1], fr.size, to.pos[0], to.pos[1], to.size);
	let enAtHerePlusDy = potentialEnergyOfPairOfNodesForRepel(fr.pos[0]+halfEpsilon, fr.pos[1], fr.size, to.pos[0]-halfEpsilon, to.pos[1], to.size);
	let enAtHerePlusDx = potentialEnergyOfPairOfNodesForRepel(fr.pos[0], fr.pos[1]+halfEpsilon, fr.size, to.pos[0], to.pos[1]-halfEpsilon, to.size);
	let dEnergyOverDy = (enAtHerePlusDy-enAtHere)/epsilon;
	let dEnergyOverDx = (enAtHerePlusDx-enAtHere)/epsilon;
	let ay = dt*dEnergyOverDy/2; //FIXME is /2 right?
	let ax = dt*dEnergyOverDx/2;
	fr.accel[0] -= ay;
	fr.accel[1] -= ax;
	to.accel[0] += ay; //FIXME did i get the += and -= backward?
	to.accel[1] += ax;


	/*
	let dy = nodeB.pos[0]-nodeA.pos[0];
	let dx = nodeB.pos[1]-nodeA.pos[1];
	let distSq = dy*dy+dx*dx;
	let maxDistToRepel = nodeA.size+nodeB.size;
	let maxDistSqToRepel = maxDistToRepel*maxDistToRepel;
	if(distSq < maxDistToRepel){
		let dist = Math.sqrt(distSq);
		let diff = maxDistToRepel-dist;
		
	}

	let halfEpsilon = epsilon/2;
	*/
};

//dt is change in time (seconds).
var updateUinodeAccelsForEdge = function(dt, edge){
	let halfEpsilon = epsilon/2;
	let fr = edge.from;
	let to = edge.to;
	//var potentialEnergyOfEdge = (yFrom, xFrom, sizeFrom, fromType, edgeType, toType, yTo, xTo, sizeTo)=>{
	let enAtHere = potentialEnergyOfEdge(fr.pos[0], fr.pos[1], fr.size, fr.type, edge.type, to.type, to.pos[0], to.pos[1], to.size);
	let enAtHerePlusDy = potentialEnergyOfEdge(fr.pos[0]+halfEpsilon, fr.pos[1], fr.size, fr.type, edge.type, to.type, to.pos[0]-halfEpsilon, to.pos[1], to.size);
	let enAtHerePlusDx = potentialEnergyOfEdge(fr.pos[0], fr.pos[1]+halfEpsilon, fr.size, fr.type, edge.type, to.type, to.pos[0], to.pos[1]-halfEpsilon, to.size);
	let dEnergyOverDy = (enAtHerePlusDy-enAtHere)/epsilon;
	let dEnergyOverDx = (enAtHerePlusDx-enAtHere)/epsilon;
	let ay = dt*dEnergyOverDy/2; //FIXME is /2 right?
	let ax = dt*dEnergyOverDx/2;
	fr.accel[0] -= ay;
	fr.accel[1] -= ax;
	to.accel[0] += ay; //FIXME did i get the += and -= backward?
	to.accel[1] += ax;
};

/*
var worldCenterY = 400;
let worldCenterX = 400;
let worldSoftRadius = 300; //how far from center nodes can be before they start being attracted to the center.
let worldSoftRadiusForce = 70; //tries to keep nodes in worldSoftRadius or not too far past it
*/

//fn is a wikibinator203 lambda.
//TODO this might instead be a "pointer into a Human mind", like a temporary mutable variable that sometimes generates fns (which are immutable),
//since Humans seem to need the ability to edit inside a code string without replacing their own thoughts about code outside that {...} or (...) or [...] block.
//Mutable stuff would be in UI only, not part of Wikibinator203 spec.
var UINode = function(fn){

	countUINodes++;

	//dom object, maybe a div. It may contain text (of parts of wikibinator203 code), canvas (pixels chosen by wikibinator203), or other UI parts.
	this.dob = null;

	this.type = 'TODO theres less than 20 node types, including leaf, float64, evaling, etc';
	
	//this.size = 100; //similar to radius, but its actually a rectangle so that doesnt exactly describe it.
	//this.size = 30;
	//this.size = 50;
	this.size = 45;
	
	this.pos = [Rnd()*600, Rnd()*900]; //screen position
	//this.pos = [Rnd()*500, Rnd()*500]; //screen position
	//this.pos = [100, Rnd()*500]; //screen position
	
	//this.pos = [100, 100]; //screen position
	//this.pos = [100, countUINodes*400-300]; //screen position
	//this.pos = [100+countUINodes*50, countUINodes*400-300]; //screen position
	//this.pos = [countTemp+=100,0]; //FIXME
	
	this.vel = [0, 0]; //change of this.pos per second
	
	this.accel = [0, 0]; //change of this.vel per second. this is set by TODO some code that calls edgeEnergyFunc
	
	
	this.fn = fn; //display this.fn.localName or vm.eval(...) but modified to limit how big a code string it can generate and leave some branches closed.
	
	//this.edges = {};
	this.outs = {}; //edges out. theres less than 10 edge types, and at most 1 of each kind, from fns anyways, but mindmap nodes (if i add those later) might have weighted edges and many of the same kind outward.
	//this.ins =  //can have many incoming edges.
	
	fn.ui = this;
	this.display();
	
	if(!fn().isLeaf()){
		//recurse to create UINodes in left and right childs. FIXME if theres alot of nodes, or if theres big bigstrings,
		//this should be done sparsely instead, to only display parts that open/close when look deeper.
		let lUI = uiOf(fn().l);
		let rUI = uiOf(fn().r);
		//FIXME display overlapping edges (from and to the same node) different by a few pixels side by side so one isnt hidden by the other.
		new UIEdge(this,'l',lUI); //sets this.outs.l = lUI
		new UIEdge(this,'r',rUI); //sets this.outs.r = rUI
		if(fn().l().l == S){ //uses {...} syntax, the sCurryList syntax.
			let to = fn().l().r;
			let sUI = uiOf(to);
			new UIEdge(this,'s',sUI); //sets this.outs.s = sUI
		}
	}
	
	nodes.push(this);
	let fnStr = ''+fn;
	console.log('Created uinode nodes['+(nodes.length-1)+'] for fn: '+fnStr);
	if(!fnStr){
		//let fnStr2 = ''+fn;
		throw 'Empty fnStr at nodes['+(nodes.length-1)+']';
	}
};

UINode.prototype.width = function(){
	if(!this.dob) return 1;
	return this.dob.clientWidth;
};

UINode.prototype.height = function(){
	if(!this.dob) return 1;
	return this.dob.clientHeight;
};

UINode.prototype.display = function(){
	if(!this.dob){
		this.dob = Dob(mainDiv,'div',''+this.fn);
		this.dob.style['user-select'] = 'none'; //prevent selecting node since selecting text in it interferes with dragging node
		this.dob.style.color = 'black';
		//this.dob = Dob(document.body,'div',''+this.fn);
		this.dob.style.position = cssPositionType; //relative to mainDiv?
		this.dob.style['background-color'] = randColorStr();
		//this.dob.style.height = '30px';
		//this.dob.style.height = '50px';
		//this.dob.style.width = '200px';
		//this.dob.style.width = '10px';
		//this.dob.style.background = 'url(redSawTooth.png)';
	}
	//this.dob.style.top = Math.floor(this.pos[0])+'px';
	//this.dob.style.left = Math.floor(this.pos[1])+'px';
	
	let a = 1, b = 0, c = 0, d = 1;
	let ty = this.pos[0];
	let tx = this.pos[1];
	this.dob.style.transform = 'matrix('+a+','+b+','+c+','+d+','+tx+','+ty+')';

	//this.dob.style.transform = 'matrix3d('+a+','+b+',0,0,  '+c+','+d+',0,0,  0,0,1,0,  '+tx+','+ty+',0,1)';
	
	for(key in this.outs){
		this.outs[key].display(); //display edge from this UINode
	}
};

var nodes = [];


var uiOf = function(fn){
	if(fn.ui) return fn.ui; //store it in field in the lambda (or whatever it is).
	if(vm.isLambda(fn)){
		return new UINode(fn); //sets fn.ui to that
	}else{
		throw 'TODO wrap other kind of object, thats not a wikibinator203 lambda';
	}
};

var edgeBackgroundOffset_speed = .4;

//directedGraph of UINodes
var nextState = ()=>{
	angle += .01;
	//edgeBackgroundOffset = (edgeBackgroundOffset+1)%32; //cuz pics are 1x32
	edgeBackgroundOffset = (edgeBackgroundOffset+edgeBackgroundOffset_speed)%32; //cuz pics are 1x32
	//uuUI.display(); //test
	let dt = 1/60; //FIXME measure time instead of hardcoding this
	doPhysics(1e-1);

	for(let node of nodes){
		node.display();
	}
	requestAnimationFrame(nextState);
};

//canvas
var lastTimeOf_doGraphicsDtAgeByterectAndMore = 0;
//var lastTimeOf_doGraphicsDtAgeByterectAndMore = time();

//canvas
var canv = null;

let canvH = 1024;
let canvW = canvH;

//canvas
var doGraphicsDtAgeByterectAndMore = function(){
	if(canv == null){
		canv = new FullScreenCanvas(document.body, canvH, canvW);
		
		//TODO the canvas moved on page faster (same update speed per video frame, but its rectangle on scree) as 'fixed' than 'absolute'
		
		canv.dom.style.position = 'fixed'; //relative to scroll position, always displayed nomatter where you scroll
		//canv.dom.style.position = 'absolute';
		canv.dom.style.left = '0px';
		canv.dom.style.top = '0px';
		//canv.dom.style.left = '470px';
		//canv.dom.style.top = '270px';
		canv.dom.style['z-index'] = -1000; //behind other stuff
	}
	//canv.resizeCanvas(window.innerHeight,window.innerWidth); //to screen size, if no params. change number of canvas pixels.
	let scaleCanvY = window.innerHeight/canv.dom.height;
	let scaleCanvX = window.innerWidth/canv.dom.width;
	//let scaleCanvY = 1;
	//let scaleCanvX = 1;
	///canv.dom.style.left = (canv.dom.width/2)+'px';
	//scaleCanvX = 4;
	//console.log('scaleCanvX = '+scaleCanvX+' window.innerWidth='+window.innerWidth+' canv.dom.width='+canv.dom.width);
	//canv.dom.style.transform = 'scale('+scaleCanvX+','+scaleCanvY+')'; //dont change number of canvas pixels. stretch it instead.
	//canv.dom.style.transform = 'matrix('+scaleCanvX+',0,0,'+scaleCanvY+','+((window.innerWidth-canv.dom.width)/2)+','+((window.innerHeight-canv.dom.height)/2+window.scrollY)+')'; //dont change number of canvas pixels. stretch it instead.
	//canv.dom.style.transform = 'matrix('+scaleCanvX+',0,0,'+scaleCanvY+','+(0)+','+(0)+')'; //dont change number of canvas pixels. stretch it instead.
	canv.dom.style.transform = 'matrix('+scaleCanvX+',0,0,'+scaleCanvY+','+((window.innerWidth-canv.dom.width)/2)+','+((window.innerHeight-canv.dom.height)/2)+')'; //dont change number of canvas pixels. stretch it instead.
	let now = time();
	let age = now-timeStarted; //how many seconds ago did this page transition start?
	let dt = Math.max(0, Math.min(now-lastTimeOf_doGraphicsDtAgeByterectAndMore, .2));
	lastTimeOf_doGraphicsDtAgeByterectAndMore = now;
	canv.beforePaint();
	doGraphicsDtAgeByterect(dt, age, canv.byteRect);
	canv.afterPaint();
	//setTimeout(doGraphicsDtAgeByterectAndMore, 1);
	//setTimeout(doGraphicsDtAgeByterectAndMore, 5);
	requestAnimationFrame(doGraphicsDtAgeByterectAndMore); //TODO optimize, only update canvas if pixels changed. store pixels as a fn/lambda.
	//setTimeout(doGraphicsDtAgeByterectAndMore, 30);
};

//canvas
var bootCanvas = ()=>{
	console.log('bootCanvas');
	doGraphicsDtAgeByterectAndMore();
};



//On-screen icon of the universal lambda, which you can dragAndDrop to make all possible lambdas,
//but will also make lambdas by evaling textarea and wrapping Float64Array etc.
var rootUI = null;
var mainDiv = null;
var uuUI = null;
window.onload = ()=>{
	//mainDiv = Dob(document.body,'div');
	mainDiv = document.getElementById('mainDiv');
	mainDiv.style['background-color'] = 'gray';
	rootUI = uiOf(U);
	uuUI = uiOf(U(U));
	//uiOf(U(U(U)));
	console.log('rootUI = '+rootUI);
	nextState();
	bootCanvas();
};

///////end directed graph ui///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
</script>
<script>

var dom = id=>document.getElementById(id);

//var h = '';

/*
h += 'Wikibinator203='+Wikibinator203+' Push F12 to see some tests in browser console.';
h += '\n\n<br><br>In the ops list below, from vm.opInfo, you can use op name, such as S, T, Pair, (F U) is identityFunc, etc. Some ops arent working yet. More ops will be filled in later. This is early into the wikibinator203 prototype. Try it in the textareas. When you change text in the top textarea, it evals and puts the output into the bottom textarea, which you should be able to copy into the top textarea and edit more. This will be easier once these low level basics are worked out and you can do everything (TODO) by drag and drop across the internet with your friends in realtime.';
for(let op of vm.opInfo){
	 h += '\n\n<br><br>'+JSON.stringify(op);
}
*/

let prevOnload = window.onload;
window.onload = ()=>{
	prevOnload();
	//dom('mainDiv').innerHTML = h;
	
	//let firstCode = '(S (F U) (F U) Pair)';
	//let firstCode = '[(CallParamOnItself#(S I#(F U) I) Pair) (CallParamOnItself F)]';
	//let firstCode = '[(CallParamOnItself#(S I#(F U) I) Pair) (CallParamOnItself F) CallParamOnItself]';
	//let firstCode = '[(CallParamOnItself#(S I#(F U) I) (S こんにちは世界)) (CallParamOnItself F) CallParamOnItself]';
	let firstCode =
`[
I#(F U)
Sqr#{(T *) I I}
Hypot#(
	λ [x y]
	{
		(T Sqrt)
		{
			(T +)
			{(T Sqr) (P x)}
			{(T Sqr) (P y)}
		}
	}
)
the hypotenuse of a right triangle of sides 6 and 8 is (Hypot 6 8)
]`;
	//let firstCode = '[(Pair (T T))]';
	//let firstCode = '[the first half is (Typeval U (L (R Abc#こんにちは世界))) and the second half is (Typeval U (R (R Abc))) but that seems to have a problem with the padding]';
	//let firstCode = '[(CallParamOnItself#(S I#(F U) I) (Pair こんにちは世界)) (CallParamOnItself F) CallParamOnItself]';
	dom('codeIn').value = firstCode;
	evalTextAreas();
};

//var displayDirectedGraphOfCodeInTextarea = false;
var displayDirectedGraphOfCodeInTextarea = true;

var evalTextAreas = ()=>{
	vm.refill();
	let throwE = null;
	let textOut = 'ERROR';
	try{
		let wikibinator203CodeIn = dom('codeIn').value;
		if(dom('isEvalElseOnlyParse').checked){
			console.log('Eval');
			let fnOut = Eval(wikibinator203CodeIn);
			textOut = ''+fnOut;
			if(displayDirectedGraphOfCodeInTextarea) uiOf(fnOut); //create it on screen, deeply all its l and r childs
		}else{
			console.log('Parse');
			let parseTree = Parse(wikibinator203CodeIn)
			textOut = ''+parseTree;
		}
	}catch(e){
		throwE = e;
		textOut = 'ERROR: '+e;
	}
	dom('codeOut').value = textOut;
	if(throwE) throw throwE;
};


//of wikibinator203 code string -> fn. fn means a wikibinator203 lambda that is a javascript function of 1 param.
//var Eval = vm.eval;
var Eval = (wikibinator203CodeString,optionalNamespace)=>{
	lastEval = vm.eval(wikibinator203CodeString,optionalNamespace);
	console.log('set lastEval');
	return lastEval;
};

var lastParseTree = null;
var lastEval = null;

var Parse = code=>(lastParseTree=vm.parse(code));

var mouseY = 0;
var mouseX = 0;

var dragOffsetY = 0;
var dragOffsetX = 0;
var draggingNode = null;

var nodeAtYXOrNull = (y,x)=>{
	for(let node of nodes){
		if(
			node.pos[0] <= y
			&& y < node.pos[0]+node.height()
			&& node.pos[1] <= x
			&& x < node.pos[1]+node.width()
		){
			if(1<=vm.loglev)console.log('nodeAtYXOrNull found '+node+' at y'+y+' x'+x);
			return node;
		}
	}
	return null;
};

var onMouseMove = event=>{
	mouseY = event.pageY-(mainDiv.offsetTop+mainDiv.clientHeight);
	mouseX = event.pageX-mainDiv.offsetLeft;
	//mouseY = event.clientY-mainDiv.offsetTop;
	//mouseX = event.clientX-mainDiv.offsetLeft;
	//mouseY = event.offsetY-mainDiv.offsetTop;
	//mouseX = event.offsetX-mainDiv.offsetLeft;
	logMouseAndButtonsEtc();
	if(draggingNode){
		if(1<=vm.loglev)console.log('dragging '+draggingNode);
		draggingNode.pos[0] = mouseY+dragOffsetY;
		draggingNode.pos[1] = mouseX+dragOffsetX;
	}
	/*if(rootUI){
		rootUI.pos[0] = mouseY; //just testing. fixme remove this
		rootUI.pos[1] = mouseX;
	}*/
};

var onMouseUp = event=>{
	delete buttons[event.button];
	//logMouseAndButtonsEtc();
	draggingNode = null;
};

var onMouseDown = event=>{
	buttons[event.button] = 1;
	//logMouseAndButtonsEtc();
	draggingNode = nodeAtYXOrNull(mouseY,mouseX);
	if(draggingNode && dom('isEditCodeWhenClickGraphNodeBelow').checked){
		console.log('Editing draggingNode='+draggingNode);
		startEditingUinode(draggingNode);
	}
};

var startEditingUinode = uinode=>{
	dom('codeOut').value = '';
	dom('codeIn').value = ''+uinode.fn;
};

var logMouseAndButtonsEtc = ()=>{
	if(2<=vm.loglev)console.log('y'+mouseY+' x'+mouseX+' buttons='+JSON.stringify(buttons));
};



var buttons = {};


//The above script is under the Wikibinator203 license.
</script>
<script>
//Canvas and ByteRect code are opensource MIT licensed
//(parts from benrayfield's various other projects including https://jsfiddle.net/q687fcrk/1/ and
//https://github.com/benrayfield/smartblob/blob/master/data/smartblob/WebcamSeesBendableLoopAsGameControllerAjaxToServer.html )
//and some parts from https://github.com/benrayfield/jsutils/blob/master/src/arvox/arvox.html

var dom = id=>document.getElementById(id);

//byte offsets for ByteRect, canvas, etc, in js.
const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3;
var colorDimRed = RED;
var colorDimGreen = GREEN;
var colorDimBlue = BLUE;
var colorDimAlpha = ALPHA;

var FullScreenCanvas = function(parentDom, optionalHeight, optionalWidth){
	if(parentDom === undefined) parentDom = document.body;
	this.dom = document.createElement('canvas');
	//TODO z order, in front of everything else.
	//this.dom = document.getElementById('canv'); //FIXME remove this line, use createElement instead.
	this.context = null;
	this.imageData = null;
	this.pixels = null;
	this.byteRect = null;
	parentDom.appendChild(this.dom);
	if(!optionalHeight){ //full screen, positioned absolute, else it normally goes in a div
		this.dom.style.position = 'absolute';
		this.dom.style.left = '0px';
		this.dom.style.top = '0px';
	}
	
	this.resizeCanvas = function(optionalHeight, optionalWidth){
		if(this.dom.width != window.innerWidth) this.dom.width = (optionalWidth || window.innerWidth);
		if(this.dom.height != window.innerHeight) this.dom.height = (optionalHeight || window.innerHeight);
	};
	
	//TODO optimize, if you're not reading from the canvas, maybe can skip parts of this or only call this once?
	this.beforePaint = function(){
		if(this.dom == null) throw 'No canvas';
		this.context = this.dom.getContext('2d');
		//console.log('this.dom.width = '+this.dom.width);
		this.imageData = this.context.getImageData(0, 0, this.dom.width, this.dom.height);
		this.pixels = this.imageData.data;
		this.byteRect = new ByteRect(this.pixels, this.dom.height, this.dom.width);
	};
	
	//call this after modify byteRect.bytes which contains pixel colors to write to Canvas.
	this.afterPaint = function(){
		if(this.dom == null) throw 'No canvas';
		//this.context.drawImage(this.dom, 0, 0, this.dom.width, this.dom.height);
		this.context.putImageData(this.imageData, 0, 0);
	};
	
	this.removeFromScreen = function(){
		this.dom.remove();
		this.dom = null;
		this.context = null;
		this.imageData = null;
		this.pixels = null;
		this.byteRect = null;
	};
	
	this.resizeCanvas(optionalHeight, optionalWidth);
	this.beforePaint();
};

var between = (min,val,max)=>Math.max(min,Math.min(val,max));

//readable and writable pixels as Uint8Array. A canvas is a kind of Uint8Array.
//Single pixel read and write funcs are slow unless you just do a few places.
//TODO Write horizontal lines of same color or 2 colors on end interpolating between,
//and these lines can be derived from triangle which has different color at each corner.
var ByteRect = function(bytes, height, width){
	this.bytes = bytes;
	this.height = height;
	this.width = width;
};

//TODO choose [y x] vs [x y z scale] order. Swap y and x in ByteRect params order? aftrans is [x y z scale].

ByteRect.prototype.index = function(y, x, colorDim){
	return (y*this.width+x)*4+colorDim;
};

ByteRect.prototype.read = function(y, x, colorDim){
	return this.bytes[(y*this.width+x)*4+colorDim];
};

ByteRect.prototype.readSafe = function(y, x, colorDim){
	return this.bytes[between(0,(y*this.width+x)*4+colorDim,this.bytes.length-1)];
};


ByteRect.prototype.write = function(y, x, colorDim, bright){
	this.bytes[(y*this.width+x)*4+colorDim] = bright;
};

ByteRect.prototype.writeSafe = function(y, x, colorDim, bright){
	this.bytes[between(0,(y*this.width+x)*4+colorDim,this.bytes.length-1)] = bright;
};

ByteRect.prototype.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
	if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
	let index = between(0,(y*this.width+x)*4,this.bytes.length-4);
	this.bytes[index+RED] = redByte;
	this.bytes[index+GREEN] = greenByte;
	this.bytes[index+BLUE] = blueByte;
	this.bytes[index+ALPHA] = optionalAlphaByte;
};

ByteRect.prototype.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
	if(x < 0 || this.width <= x || y < 0 || this.height <= y) return;
	let ind = (y*this.width+x)*4;
	this.bytes[ind+RED] = redByte;
	this.bytes[ind+GREEN] = greenByte;
	this.bytes[ind+BLUE] = blueByte;
};

ByteRect.prototype.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
	var indexStart = this.index(y, fromX, colorDim);
	var pixelSiz = toXExclusive-fromX;
	var siz = pixelSiz*4;
	var bright = fromBright;
	var brightAdd = (toBright-fromBright)/pixelSiz;
	for(var i=0; i<siz; i+=4){
		bright += brightAdd;
		this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
	}
};

//modifies this ByteRect
ByteRect.prototype.flipHorizontal = function(){
	let bytes = this.bytes;
	for(let y=0; y<this.height; y++){
		let xMid = Math.floor(this.width/2);
		let offsetA = y*this.width*4; //first byte index of first pixel in row
		let offsetB = ((y+1)*this.width-1)*4; //first byte of last pixel in row
		for(let x=0; x<xMid; x++){
			for(let colorDim=0; colorDim<4; colorDim++){ //swap 2 pixels as 4 bytes each
				let temp = bytes[offsetA+colorDim];
				bytes[offsetA+colorDim] = bytes[offsetB+colorDim];
				bytes[offsetB+colorDim] = temp;
			}
			offsetA += 4;
			offsetB -= 4;
		}
	}
};

//modifies this ByteRect
ByteRect.prototype.flipVertical = function(){
	let bytes = this.bytes;
	for(let y=0; y<this.height/2; y++){
		let oppY = this.height-1-y;
		let len = this.width*4;
		let offsetA = y*len;
		let offsetB = oppY*len;
		for(let i=0; i<len; i++){
			let temp = bytes[offsetA+i];
			bytes[offsetA+i] = bytes[offsetB+i];
			bytes[offsetB+i] = temp;
		}
	}
};

ByteRect.prototype.verifySameSizeAs = function(byteRect){
	if(!byteRect) throw 'Param ByteRect = '+byteRect;
	if(this.height != byteRect.height) throw this.height+' == this.height != byteRect.height == '+byteRect.height;
	if(this.width != byteRect.width) throw this.width+' == this.width != byteRect.width == '+byteRect.width;
};

/*
//returns a new ByteRect of given size
ByteRect.prototype.resize = function(newHeight, newWidth){
	let newBytes = new Uint8Array(newHeight*newWidth*4);
	let ret = new ByteRect(newBytes, newHeight, newWidth);
	for(let newY=0; newY<newHeight; newY++){
		//let oldYSmooth = newY*this.height/newHeight; //smooth for bilinear interpolation
		let oldY = Math.floor(newY*this.height/newHeight);
		for(let newX=0; newX<newWidth; newX++){
			//let oldXSmooth = newX*this.width/newWidth;
			//let oldXLow = Math.floor(oldXSmooth);
			//let oldXHigh = Math.min();
			let oldX = Math.floor(newX*this.width/newWidth);
			//let oldIndex = (oldY*this.width+oldX)*4;
			//let newIndex = (newY*newWidth+newX)*4;
			//let oldIndex = this.index(oldY, oldX, colorDim);
			//let newIndex = ret.index(newY, newX, colorDim);
			for(let colorDim=0; colorDim<4; colorDim++){
				ret.bytes[newIndex+colorDim] = this.bytes[oldIndex+colorDim];
			}
		}
	}
	return ret;
};*/

//returns a new ByteRect of given size
ByteRect.prototype.resize = function(newHeight, newWidth){
	let newBytes = new Uint8Array(newHeight*newWidth*4);
	let ret = new ByteRect(newBytes, newHeight, newWidth);
	for(let newY=0; newY<newHeight; newY++){
		let oldY = Math.floor(newY*this.height/newHeight);
		for(let newX=0; newX<newWidth; newX++){
			let oldX = Math.floor(newX*this.width/newWidth);
			let oldIndex = (oldY*this.width+oldX)*4;
			let newIndex = (newY*newWidth+newX)*4;
			//let oldIndex = this.index(oldY, oldX, colorDim);
			//let newIndex = ret.index(newY, newX, colorDim);
			for(let colorDim=0; colorDim<4; colorDim++){
				ret.bytes[newIndex+colorDim] = this.bytes[oldIndex+colorDim];
			}
		}
	}
	return ret;
};

ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	for(let i=0; i<numPoints; i++){
		//TODO optimize
		let y = Math.round(fromY+diffY*i/numPoints);
		let x = Math.round(fromX+diffX*i/numPoints);
		this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
	}
};

ByteRect.picDataUrlToByterect = function(dataUrl_or_url,asyncGetByteRect){
	const img = document.createElement('img');
	//img.crossOrigin = "Anonymous";

	let func = function(event){	
		const canv = document.createElement('canvas');
		canv.width = img.width;
		canv.height = img.height;
		document.body.appendChild(canv);
		let cx = canv.getContext('2d');
		cx.drawImage(img, 0, 0);
		//if(!img.width) throw 'w';
		let dd = cx.getImageData(0, 0, img.width, img.height);
		//let dd = cx.getImageData(0, 0, 264, 264);
		let d = dd.data;
		let arr = new Uint8Array(d.length);
		for(let i=0; i<arr.length; i++) arr[i] = d[i];
		let ret = new ByteRect(arr, img.height, img.width);
		asyncGetByteRect(ret);
		canv.remove();
		img.remove();
	};
	
	//requestAnimationFrame(func);
	img.onload = func;
	img.src = dataUrl_or_url;
	document.body.appendChild(img);
};

const timeOffset_ = performance.timing.navigationStart;

//utc seconds, with a little more precision than Date.now()*.001
const time = ()=>((timeOffset_+performance.now())*.001);

var timeStarted = 0;

/** get bellcurve height on a chosen bellcurve thats stretched and moved */
var bell = function(ave, dev, maxHeight, observe){
	let diff = (observe-ave)/dev;
	return Math.exp(-diff*diff);
};

var sigmoid = function(x){
	return .5+.5*Math.tanh(x);
};

var asByte = num=>(Math.max(0,Math.min(Math.floor(num),255))|0);

//0 to 255
var backgroundRed = 0;
var backgroundGreen = 0;
var backgroundBlue = 0;


//age in seconds since transition started. Just paints onto ByteRect
var doGraphicsDtAgeByterect = function(dt, age, byteRect){

	let bytes = byteRect.bytes;
	let offset = Math.floor(Math.sin(time()*5*2*Math.PI)*100+100);
	let w = byteRect.width;
	let h = byteRect.height;
	let cx = Math.floor(w/2); //center x
	let cy = Math.floor(h/2); //center y
	for(let i=0; i<bytes.length; i+=4){
		bytes[i+RED] = backgroundRed;
		bytes[i+GREEN] = backgroundGreen;
		bytes[i+BLUE] = backgroundBlue;
		bytes[i+ALPHA] = 255;
	}
	let i = 0;
	for(let y=0; y<h; y++){
		for(let x=0; x<w; x++){
			bytes[i+RED] = (x+age*35)&255;
			bytes[i+GREEN] = (x+y*age)&255;
			bytes[i+BLUE] = (333*x/y)&255;
			i += 4;
		}
		i += w*4; //row of pixels
	}

};

//sets this.weightedSum and this.weight, starting with weight 1 and weightedSum is copied from bytes
ByteRect.prototype.createTwoFloatsEachIfNotExist = function(){
	if(!this.weightedSum){
		this.weightedSum = new Float32Array(this.bytes.length);
		this.weight = new Float32Array(this.bytes.length);
		this.countWeights = new Int32Array(this.bytes.length); //how many times was anything added to [both at once: this.weight and this.weightedSum]?
	}
};

ByteRect.prototype.addBytesToWeightedSums = function(weight){
	this.createTwoFloatsEachIfNotExist();
	for(let i=0; i<this.bytes.length; i++){
		//let sum = this.weightedSum[i]*this.weight[i];
		this.weightedSum[i] += weight*this.bytes[i];
		this.weight[i] += weight;
	}
};

ByteRect.prototype.copyWeightedSumsToBytes = function(){
	for(let i=0; i<this.bytes.length; i++){
		this.bytes[i] = asByte(this.weightedSum[i]/this.weight[i]); //0 if weight is 0.
	}
};

ByteRect.prototype.addColorToWeightedSumByBilinearInterpolation = function(y, x, red, green, blue, alpha, weight){
	let yLow = Math.floor(y);
	let xLow = Math.floor(x);
	let yFraction = y-yLow;
	let xFraction = x-xLow;
	let yHigh = yLow+1; //FIXME does this go off edge of pic ever?
	let xHigh = xLow+1;
	this.addColorToWeightedSum((yLow*this.width+xLow)*4, red, green, blue, alpha, (1-yFraction)*(1-xFraction)*weight);
	this.addColorToWeightedSum((yLow*this.width+xHigh)*4, red, green, blue, alpha, (1-yFraction)*xFraction*weight);
	this.addColorToWeightedSum((yHigh*this.width+xLow)*4, red, green, blue, alpha, yFraction*(1-xFraction)*weight);
	this.addColorToWeightedSum((yHigh*this.width+xHigh)*4, red, green, blue, alpha, yFraction*xFraction*weight);
};

ByteRect.prototype.addColorToWeightedSum = function(i, red, green, blue, alpha, weight){
	//let i = (y*this.width+x)*4;
	this.weightedSum[i+RED] += red*weight;
	this.weightedSum[i+GREEN] += green*weight;
	this.weightedSum[i+BLUE] += blue*weight;
	this.weightedSum[i+ALPHA] += alpha*weight;
	this.weight[i+RED] += weight;
	this.weight[i+GREEN] += weight;
	this.weight[i+BLUE] += weight;
	this.weight[i+ALPHA] += weight;
	this.countWeights[i+RED]++;
	this.countWeights[i+GREEN]++;
	this.countWeights[i+BLUE]++;
	this.countWeights[i+ALPHA]++;
};

ByteRect.prototype.getWeightedSum = function(i){
	return (this.weightedSum[i]/this.weight[i])|0.0;
};


/*var lastTimeOf_doGraphicsDtAgeByterectAndMore = 0;

var doGraphicsDtAgeByterectAndMore = function(){
	if(canv == null){
		canv = new FullScreenCanvas(document.body,200,300);
	}
	let now = time();
	let age = now-timeStarted; //how many seconds ago did this page transition start?
	let dt = Math.max(0, Math.min(now-lastTimeOf_doGraphicsDtAgeByterectAndMore, .2));
	lastTimeOf_doGraphicsDtAgeByterectAndMore = now;
	canv.beforePaint();
	doGraphicsDtAgeByterect(dt, age, canv.byteRect, picByteRect);
	canv.afterPaint();
	setTimeout(doGraphicsDtAgeByterectAndMore, 1);
};


window.onload = ()=>{
	timeStarted = time();
	doGraphicsDtAgeByterectAndMore();
};*/



/*
//appends to innerHTML, not replace
var createControlsForAftransInDiv = function(aftrans, div, optionalStep){
	if(!optionalStep) optionalStep = .1;
	let html = '<table border=0><tr><td>';
	let varName = newVar(aftrans);
		let labelId = newId();
	for(let i=0; i<aftrans.length; i++){
		let inner = i%4;
		let outer = (i-inner)/4; //0..4
		if(inner == 0) html += '<br><nobr>\n';
		html += '<input type=number min="-1000" max="1000" step="'+optionalStep+'" oninput="'+varName+'['+i+'] = this.valueAsNumber; dom(\''+labelId+'\').innerHTML = aftransStr('+varName+');" value="'+aftrans[i]+'"></input>';
		if(inner == 3) html += '</nobr>\n';
		//div.innerHTML += '<nobr><input type=range id="'+id+'" min="0" max="1000000" value="'+(fieldValToFraction(firstVal)*1000000)+'"'
		//	+' oninput="let num = '+MUL+'*(Math.pow('+BASE+', between(0,this.valueAsNumber/1000000,1))-1); sim.'+FIELD+' = num; dom(\''+id2+'\').innerHTML = //\''+FIELD+' = \'+num;"></input><label id="'+id2+'">'+FIELD+'='+sim[FIELD]+'</label></nobr><br> ';
	}
	html += '<td><td>';
	//html += '<br><input type=button onclick="" value="copy aftrans to these^, in case something other than these changed it"></input>
	html += '<br><label id='+labelId+'>'+aftransStr(aftrans)+'</label>'; //keep updated as aftransStr(aftrans) if changes from the 16 numberfields
	html += '</td></tr></table>&nbsp;&nbsp;';
	div.innerHTML += html;
};*/

var createNumberChooserForVarName = function(varName, div, optionalStep, onChange){
	let varNameOfOnChange = newVar(onChange);
	let html = '<nobr>'+varName+'=<input type=number min="-1000" max="1000" step="'+optionalStep+'" oninput="'+varName+' = this.valueAsNumber; if('+varNameOfOnChange+') '+varNameOfOnChange+'();" value="'+eval(varName)+'"></input></nobr>';
	div.innerHTML += html;
};

var rememberLabelId_from_createControlsForAftrans4x4InDiv = null;

//appends to innerHTML, not replace
var createControlsForAftrans4x4InDiv = function(aftrans, div, optionalStep, onChange, optionalListOfOtherVars, optionalVarNameOfAftrans){
	if(!optionalStep) optionalStep = .1;
	if(!optionalListOfOtherVars) optionalListOfOtherVars = [];
	if(!optionalVarNameOfAftrans) optionalVarNameOfAftrans = 'theAftrans';
	let html = '<table border=0><tr><td>';
	let varName = newVar(aftrans);
	let varNameOfOnChange = newVar(onChange);
	let labelId = newId();
	//if(rememberLabelId_from_createControlsForAftrans4x4InDiv) throw 'already have a rememberLabelId_from_createControlsForAftrans4x4InDiv='+rememberLabelId_from_createControlsForAftrans4x4InDiv;
	//rememberLabelId_from_createControlsForAftrans4x4InDiv = labelId;
	for(let i=0; i<4; i++){
		html += '<nobr>';
		for(let j=0; j<4; j++){
			//let inner = i%4;
			//let outer = (i-inner)/4; //0..4
			//if(inner == 0) html += '<br><nobr>\n';
			html += '<input type=number min="-1000" max="1000" step="'+optionalStep+'" oninput="'+varName+'['+i+']['+j+'] = this.valueAsNumber; dom(\''+labelId+'\').innerHTML = aftrans4x4Str('+varName+'); if('+varNameOfOnChange+') '+varNameOfOnChange+'();" value="'+aftrans[i][j]+'"></input>';
			//if(inner == 3) html += '</nobr>\n';
			//div.innerHTML += '<nobr><input type=range id="'+id+'" min="0" max="1000000" value="'+(fieldValToFraction(firstVal)*1000000)+'"'
			//	+' oninput="let num = '+MUL+'*(Math.pow('+BASE+', between(0,this.valueAsNumber/1000000,1))-1); sim.'+FIELD+' = num; dom(\''+id2+'\').innerHTML = //\''+FIELD+' = \'+num;"></input><label id="'+id2+'">'+FIELD+'='+sim[FIELD]+'</label></nobr><br> ';
		}
		html += '</nobr><br>';
	}
	html += '<td><td>';
	//html += '<br><input type=button onclick="" value="copy aftrans to these^, in case something other than these changed it"></input>
	let otherVars = '';
	for(let varNameB of optionalListOfOtherVars) otherVars += ' '+varNameB+' = '+eval(varNameB)+';';
	//html += '<br><label id='+labelId+'>'+optionalVarNameOfAftrans+' = '+aftrans4x4Str(aftrans,optionalListOfOtherVars,optionalVarNameOfAftrans)+';'+otherVars+'</label>'; //keep updated as aftransStr(aftrans) if changes from the 16 numberfields
	html += '</td></tr></table>&nbsp;&nbsp;';
	//let rotateHowMuchPerButtonClick = .005;
	let rotateHowMuchPerButtonClick = optionalStep;
	html += '<input type=button onclick="rotate01('+varName+','+rotateHowMuchPerButtonClick+'); dom(\''+labelId+'\').innerHTML = aftrans4x4Str('+varName+'); if('+varNameOfOnChange+') '+varNameOfOnChange+'();" value="rotate01+"></input>';
	html += '<input type=button onclick="rotate01('+varName+','+(-rotateHowMuchPerButtonClick)+'); dom(\''+labelId+'\').innerHTML = aftrans4x4Str('+varName+'); if('+varNameOfOnChange+') '+varNameOfOnChange+'();" value="rotate01-"></input>';
	html += ' <input type=button onclick="rotate12('+varName+','+rotateHowMuchPerButtonClick+'); dom(\''+labelId+'\').innerHTML = aftrans4x4Str('+varName+'); if('+varNameOfOnChange+') '+varNameOfOnChange+'();" value="rotate12+"></input>';
	html += '<input type=button onclick="rotate12('+varName+','+(-rotateHowMuchPerButtonClick)+'); dom(\''+labelId+'\').innerHTML = aftrans4x4Str('+varName+'); if('+varNameOfOnChange+') '+varNameOfOnChange+'();" value="rotate12-"></input>';
	html += ' <input type=button onclick="rotate02('+varName+','+rotateHowMuchPerButtonClick+'); dom(\''+labelId+'\').innerHTML = aftrans4x4Str('+varName+'); if('+varNameOfOnChange+') '+varNameOfOnChange+'();" value="rotate02+"></input>';
	html += '<input type=button onclick="rotate02('+varName+','+(-rotateHowMuchPerButtonClick)+'); dom(\''+labelId+'\').innerHTML = aftrans4x4Str('+varName+'); if('+varNameOfOnChange+') '+varNameOfOnChange+'();" value="rotate02-"></input> ';
	html += '<input type=button onclick="setToIdentityMatrix('+varName+'); dom(\''+labelId+'\').innerHTML = aftrans4x4Str('+varName+'); if('+varNameOfOnChange+') '+varNameOfOnChange+'();" value="identity matrix 4x4"></input> ';
	html += '<br><label id='+labelId+'>'+optionalVarNameOfAftrans+' = '+aftrans4x4Str(aftrans,optionalListOfOtherVars,optionalVarNameOfAftrans)+';'+otherVars+'</label>'; //keep updated as aftransStr(aftrans) if changes from the 16 numberfields
	div.innerHTML += html;
};

//used by createControlsForAftransInDiv to refer to js objects in a string of code outside this namespace.
var vars = {};

//Example: let x = newVar(10); eval(x+' = x*x+5;'); eval(x) is 105.
//used by createControlsForAftransInDiv to refer to js objects in a string of code outside this namespace.
var newVar = function(val){
	let id = newId();
	vars[id] = val;
	return 'vars.'+id;
};


var nextIdNum = 0;
//prefix is optional
var newId = function(prefix){
	if(!prefix) prefix = 'id';
	return (prefix+(nextIdNum++));
};

/*let aftransStr = function(aftrans){
	return 'Float32Array.of('+aftrans[0]+', '+aftrans[1]+', '+aftrans[2]+', '+aftrans[3]+', '
		+aftrans[4]+', '+aftrans[5]+', '+aftrans[6]+', '+aftrans[7]+', '
		+aftrans[8]+', '+aftrans[9]+', '+aftrans[10]+', '+aftrans[11]+', '
		+aftrans[12]+', '+aftrans[13]+', '+aftrans[14]+', '+aftrans[15]+')';
};*/

let aftrans4x4Str = function(aftrans, optionalListOfOtherVars, optionalVarNameOfAftrans){
	if(!optionalListOfOtherVars) optionalListOfOtherVars = [];
	if(!optionalVarNameOfAftrans) optionalVarNameOfAftrans = 'theMatrix4x4';
	let html = '';
	let aft = '<nobr>[['+aftrans[0][0]+', '+aftrans[0][1]+', '+aftrans[0][2]+', '+aftrans[0][3]+'],</nobr><br>'
		+'<nobr>['+aftrans[1][0]+', '+aftrans[1][1]+', '+aftrans[1][2]+', '+aftrans[1][3]+'],</nobr><br>'
		+'<nobr>['+aftrans[2][0]+', '+aftrans[2][1]+', '+aftrans[2][2]+', '+aftrans[2][3]+'],</nobr><br>'
		+'<nobr>['+aftrans[3][0]+', '+aftrans[3][1]+', '+aftrans[3][2]+', '+aftrans[3][3]+']]</nobr>';
	let otherVars = '';
	for(let varName of optionalListOfOtherVars){
		console.log('varName='+varName);
		otherVars += ' '+varName+' = '+eval(varName)+';';
	}
	//let labelId = newId();
	//if(!rememberLabelId_from_createControlsForAftrans4x4InDiv) throw 'no rememberLabelId_from_createControlsForAftrans4x4InDiv';
	//let labelId = rememberLabelId_from_createControlsForAftrans4x4InDiv;
	let labelId = 'TODO_labelId';
	html += '<br><label id='+labelId+'>'+optionalVarNameOfAftrans+' = '+aft+';'+otherVars+'</label>'; //keep updated as aftransStr(aftrans) if changes from the 16 numberfields
	html = html.replaceAll(';;',';'); //FIXME whats putting the extra ;?
	return html;
};


//https://www3.nd.edu/~pbui/teaching/cse.40166.fa10/slides/Lecture_4_Transformations_and_Matrices.pdf
var aftrans4x4ToRotate01 = angle=>[
	[Math.cos(angle), -Math.sin(angle), 0, 0],
	[Math.sin(angle), Math.cos(angle), 0, 0],
	[0, 0, 1, 0],
	[0, 0, 0, 1]
];

var aftrans4x4ToRotate02 = angle=>[
	[Math.cos(angle), 0, -Math.sin(angle), 0],
	[0, 1, 0, 0],
	[Math.sin(angle), 0, Math.cos(angle), 0],
	[0, 0, 0, 1]
];

var aftrans4x4ToRotate12 = angle=>[
	[1, 0, 0, 0],
	[0, Math.cos(angle), -Math.sin(angle), 0],
	[0, Math.sin(angle), Math.cos(angle), 0],
	[0, 0, 0, 1]
];

var mulAftrans4x4By4x4 = (aftransA,aftransB)=>{
	let aftrans = [[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]];
	for(let i=0; i<4; i++){
		for(let j=0; j<4; j++){
			for(let k=0; k<4; k++){
				aftrans[i][j] += aftransA[i][k]*aftransB[k][j];
			}
		}
	}
	return aftrans;
};

var copyAftrans4x4Into4x4 = (from,to)=>{
	for(let i=0; i<4; i++){
		for(let j=0; j<4; j++){
			to[i][j] = from[i][j];
		}
	}
};

//modifies aftrans
var rotate01 = (aftrans,angle)=>{
	copyAftrans4x4Into4x4(mulAftrans4x4By4x4(aftrans,aftrans4x4ToRotate01(angle)),aftrans);
};

//modifies aftrans
var rotate02 = (aftrans,angle)=>{
	copyAftrans4x4Into4x4(mulAftrans4x4By4x4(aftrans,aftrans4x4ToRotate02(angle)),aftrans);
};

//modifies aftrans
var rotate12 = (aftrans,angle)=>{
	copyAftrans4x4Into4x4(mulAftrans4x4By4x4(aftrans,aftrans4x4ToRotate12(angle)),aftrans);
};

var setToIdentityMatrix = aftrans=>{
	copyAftrans4x4Into4x4([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],aftrans);
};
</script>
</head><body onmousemove="onMouseMove(event);" onmousedown="onMouseDown(event);" onmouseup="onMouseUp(event);" style="color:white;background-color:black">
	<center>
		<h2><div style="background-color:black">Agree (no checkbox) to the opensource <a href="#theLicense">license</a> at bottom of this file or dont use this.</div> Wikibinator203, <a href=https://github.com/benrayfield/wikibinator203>https://github.com/benrayfield/wikibinator203</a> a programming language where everything is made of a universal function called on itself in many combos. This is an early experiment and will be easier to play with when it has voxel graphics and is a massively-multiplayer compute cloud. Imagine millions of people doing this in an infinite dimensional turing-complete space, but not able to get in eachothers way since the directed-graph you see below, of working javascript lambdas (try them on browser console or here) is immutable/stateless, a lazy-evaled merkle-forest. Scroll down for some example code to copy/paste into IN textarea below.</h2>
		<br><br>
		λ means Lambda.
		(λ [a b c] T) and node.prototype.p(name)<br>
		(P a (λ [a b c] T Pair)) -> Pair<br>
		(P a (λ [a b c] T Pair S)) -> Pair<br>
		(P b (λ [a b c] T Pair S)) -> S<br>
		(λ [a b c] (P a) Pair S L) -> Pair<br>
		(λ [a b c] (P b) Pair S L) -> S<br>
		(λ [a b c] (P c) Pair S L) -> L<br>
		[backward is words some are these]<br>
		Lambda/λ opcode works now. abc means (Typeval U BytesOf_abc) aka "abc". 	 --> [backward is words some are these]<br>
		<nobr>OUT:<textarea id=codeOut rows="10" cols="100" readonly></textarea></nobr><br>
		<nobr>IN:<textarea id=codeIn rows="20" cols="100" oninput="evalTextAreas();"></textarea></nobr><br>
		<input type=checkbox id=isEvalElseOnlyParse checked oninput="evalTextAreas();"></input><label for=isEvalElseOnlyParse>eval (else parse only)</label><br>
		<input type=checkbox id=isEditCodeWhenClickGraphNodeBelow checked></input><label for=isEditCodeWhenClickGraphNodeBelow>when click below, edit code here</label><br>
	</center>
	<br>
	<div id="mainDiv">>mainDiv</div>
	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	<center>
		Test Wikibinator203 prototype (incomplete but works a little)<br>
		Wikibinator203 code in. It evals while you type,<br>
		but until vm.stackTime and vm.stackMem are working,<br>
		you might have to close and reopen browser tab if you write an infinite loop). Example: (Pair (F U) S F) -> S<br>
		Example: [(APair#(Pair こんに ちは世界) F) (APair T)]<br>
		Example: [the first half is (Typeval U (L (R Abc#こんにちは世界))) and the second half is (Typeval U (R (R Abc))) but that seems to have a problem with the padding]<br>
		Example: (Pair (F U) S T) -> (F U)<br>
		Example: Pair -> Pair<br>
		Example: ([L R L R] Pair Pair L S R) -> [L R L R Pair Pair L S R]<br>
		Example: (L ([L R L R] Pair Pair L S R)) -> [L R L R Pair Pair L S]<br>
		Example: (R ([L R L R] Pair Pair L S R)) -> R<br>
		Example: (L U (R U)) -> U<br>
		Example: (L L (R L)) -> L<br>
		Example: (L R (R R)) -> R<br>
		Example: (L S (R S)) -> S<br>
		Example: (L (Pair S T) (R (Pair S T))) -> (Pair S T) - aka (Pair S T) is the iota lambda<br>
		Example: ((Pair S T) (Pair S T) [L R L R S]) -> [L R L R S] - cuz iota called on itself is an identityFunc.<br>
		Example: ((Pair S T) (Pair S T) (Pair S T)) -> (Pair S T) - cuz iota called on itself is an identityFunc.<br>
		Example: ((Pair S T) ((Pair S T) ((Pair S T) (Pair S T)))) -> T<br>
		- as in https://en.wikipedia.org/wiki/Iota_and_Jot cuz T is the K of SKI-Calculus.<br>
		Example: ((Pair S T) ((Pair S T) ((Pair S T) ((Pair S T) (Pair S T))))) -> S<br>
		- as in https://en.wikipedia.org/wiki/Iota_and_Jot cuz T is the K of SKI-Calculus.<br>
		This is an infinite loop (though runs out of javascript stack: (S (F U) (F U) (S (F U) (F U)))<br>
		It will be much easier use when Names#(...) and drag-and-drop and 1024x1024 per pixel graphics are working.<br>
		<br><br>
		TODO, M[...] syntax aka (M [...]) where a lack of whitespace between 2 things means call one on the other, and : between them will do the same thing.
		<br><br>
		TODO, something I'll build to improve the UI later... Right click any node to edit it as a string of code, in its dom node (dob), which as you type creates/finds new nodes below it (or only if you push a certain button since that might be confusing to have stuff change so fast), and while editing you can choose a subset of the nodes on screen that can reach it by l and r edges (easiest way is edit nodeA as viewed from nodeB which can reach nodeA, and a button to save a snapshot of it into the nodes directed graph), and that subset can be copied then modified or just modified, and such modifying/editing does not affect the 256 bit ids (TODO ids) of the nodes, just is different lambdas.<br>
	</center>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<a name="theLicense"><div style="background-color:black">
LICENSE AT TIME 2022-8-3 IS THIS BUT TODO COPY CHANGED LICENSE (BEFORE FINALIZING IT SOMEDAY) FROM LICENSE FILE WHEN CHANGED:[[[
Ben F Rayfield offers the wikibinator203 VM prototype, UI, and various tools, under this license
<br><br>
I (Ben F Rayfield) know this license is a mess and am planning to rewrite it to be much smaller,
divided into small paragraphs, move some parts to tutorials or other documents about the software,
and only keep the parts that arent strongly implied by the other parts.
Now that I've written about the "infinite size unweighted directed-graph with 3 edge-colors",
that seems an easier way to explain why it would cause problems for
specific people to own specific nodes and edges in that directed-graph,
and that nodes could be dangerous if copied into executable files outside the system, etc.
<br><br>
This license contains the 3 paragraphs of the MIT license and some extra copyleft stuff.
<br><br>
This is experimental software.
<br><br>
[THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.] (COPIED FROM LAST PARAGRAPH OF MIT LICENSE, APPLIES HERE)
<br><br>
This software uses a constant infinite size unweighted directed-graph
with 3 edge-colors, that contains all possible patterns of finite
amount of information that take finite amount of compute time and memory,
which an infinite number of subsets of it (if not the whole thing?)
are already near optimally compressed (near lowest kolmogorov complexity)
in its natural form. These edges are Func, Param, and EvalsTo,
where Func called on Param returns EvalsTo. Nobody owns that directed-graph
nor any nodes or edges in it,
nor the using of it as lambdas/wikibs (nodes are lambdas/wikibs).
Nobody owns wikibs. They are shared facts of maths many people and software
can use together. A wikib is a kind of number, stateless and immutable
(or approximations of it in some ways of using it)
universal lambda function, combinator, pattern-calculus function, fact of math,
a pure function, and a data structure that is defined completely as a forest
node with 2 child wikibs down to leaf (leaf also has 2 childs (identity
function and leaf)). Leaf (aka U aka Wikibinator203) is the universal
function, from which all turing-complete patterns of finite amount of
information can be built, used, and shared. Forall wikib x, forall wikib y,
x called on y is a wikib, which may be halted or evaling (to a halted wikib
or never halts). Every wikib is a derivative-work of leaf, which can be
proven by calling leaf on itself in various combinations, to make any wikib.
While obeying this license and using a wikibinator203 VM that correctly
implements the spec, it is safe to call any wikib on any wikib since all
it does is find or create wikibs, but if its used to control external
systems (such as robots, buying and selling things, or telling people
what to believe or what to do outside a simulated world, or copying a
wikib to a new file, renaming that file x.exe, then double-clicking that
file), it is entirely the responsibility of who hooks it to those systems
to verify its safe, such as by math proofs, networks of digital signatures,
or other evidence, especially considering that it can create all possible
computer viruses and ransomware and other evil things (safely in a
sandbox across 1 or many computers) and good things, and that in 1 of
its 2 namespaces (evilbit=true), it is an antivirus quarantine and
uncensored area, a sandbox across whichever computers opt into using
this data structure together, where all possible wikibs are allowed.
In the antivirus quarantine, you may share viruses like posts in a
social network, turing-complete messages that others may, for example,
say ["this is a virus" TheVirus] or use the virus in a meme-like piece
of art (such as a satirical work making fun of viruses could literally
contain such viruses) and do experiments, make games, musical
instruments, tools, or anything of pure information. It would be very
destructive to the system if there is any possible math statement which
is not allowed, such as removing a virus or other "evil" wikibs while
it has incoming pointers. It would be destructive to the wikib systems,
because halting-oracles have been proven impossible, and a halting-oracle
would be needed to determine if a certain wikib would generate, or would
not generate, a certain other wikib, without waiting up to an infinite
time to observe what it does (by the universal lambda math). The other
namespace (evilbit=false) works like the normal internet, if those who
opt in can find a way to do that without breaking the wikib math so much
its unusable, a way to claim a certain wikib is safe, unlike in
evilbit=true where there is no reasonable expectation that it is safe
to give those wikibs execute permission, or to believe any information
in them, or to obey anything they might tell you to do with a message
on the screen. It would be negligence for someone to give execute
permission to, believe, or obey, anything in an antivirus quarantine
(which many apps may run inside across many computers) if that causes
a problem, and similarly for the evilbit=false area, since saying its
evilbit=true or evilbit=false (which happens in the first byte of a
256 bit id for example) is just a word that people or computers can
say about a wikib, that they believe it to be safe or not.
If in doubt, use evilbit=true aka antivirus quarantine.
The 256 (or 512) bit ids can safely be shared in public as #hashtags.
The sending and receiving of this data structure across a network
does not count that network as an "external system"
and is part of the sandbox. Similarly, a Human just using the
facts of math together with other Humans and AIs, is part of the sandbox,
as a wikib can exist inside a Human mind (which is turing-complete),
but believing or obeying it in the Human mind is outside the sandbox.
A wikib being a "fact of math" is inside the sandbox,
and can derive its own ids which are similar to godel-numbers,
and in the pure deterministic (not "approximations") way of using it,
it can not lie about anything inside the sandbox,
but if its viewed as statements about outside the sandbox those can be lies.
For example, the wikib "this sentence is false", and "two plus two equals five",
are both true, since those are just utf8 bytes, and it is true that
they do not break any rules of the universal lambda,
but if you view them as statements about natural-language
then that refers to patterns of thoughts outside the sandbox.
If instead you derive numbers and use the Ax opcode to prove
a function called on a param gives a certain return value,
then it will not halt if you try to eval either of those in pure math form.
All halted wikibs are true. All wikibs which will never halt are false.
Approximations of wikibs can guarantee halting by recursively limiting
compute time and memory etc, so in theory there should be some way
to safely use it to operate time critical dangerous processes
in the evilbit=true area, but due to the evilbit=false area
"throwing a wrench into the machine" by removing pieces of math
based on Human opinions etc, the antivirus quarantine is safest.
The antivirus quarantine, in the way its the math that the code is based on,
has already whitelisted an infinite set,
(of all of a certain kind of universal function, by calling it on itself in various combos)
unlike the common practice of blacklisting "evil" things as they are
observed or predicted over time. The only thing the antivirus quarantine blacklists
is mutable state. A pure function can not infect a harddrive or RAM etc,
since it can not call thePureFunction(mutableState)->next_mutableState,
except to store cached function calls (including wrapping tiny and bigdata size bitstrings).
A virus is only dangerous if it can modify some mutable state.
This is a formal-verification system. This is also a low-latency number-crunching turing-complete system.
For example, this system's turing-complete-type-system can have a linked-list of lambdas
that when called on [church-pair of themself and themself] evals to one of the representations of the exact value of pi,
and if you tried to insert into that linked-list a value not matching that, it would never halt,
and if you tried to insert, in parallel a million values matching that,
you would in each of those million wikib_called_on_wikib get a linked-list with 1 more thing in it.
<br><br>
If there is any conflict between the above "Nobody owns wikibs" paragraph and the below 2 paragraphs copied from MIT license,
then that "Nobody owns wikibs" paragraph wins, overpowers the legal effects, of the 2 paragraphs below,
and if that is not legally possible to do then it is not legally possible to use this software at all.
<br><br>
Except for the "Nobody owns wikibs" paragraph above, which in a copyleft way applies to every wikibinator203 VM,
permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<br><br>
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
]]]
</div></a>
</body></html>
