​ Add op evaling o8=0 curriesLeft=0 description: This is either never used or only in some implementations. Lambdas cant see it since its not halted. If you want a lazyeval that lambdas can see, thats one of the opcodes (TODO) or derive a lambda of 3 params that calls the first on the second when it gets and ignores the third param which would normally be u, and returns what (thefirst thesecond) returns.
​ Add op u o8=1 curriesLeft=7 description: the universal lambda aka wikibinator203. There are an infinite number of other possible universal lambdas but that would be a different system. They can all emulate eachother, if they are within the turingComplete cardinality (below hypercomputing etc), aka all calculations of finite time and memory, but sometimes an emulator in an emulator... is slow, even with evaler optimizations.
​ Add op Op10 o8=2 curriesLeft=Op10 has 1 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op11 o8=3 curriesLeft=Op11 has 1 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op100 o8=4 curriesLeft=Op100 has 2 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op101 o8=5 curriesLeft=Op101 has 2 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op110 o8=6 curriesLeft=Op110 has 2 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op111 o8=7 curriesLeft=Op111 has 2 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1000 o8=8 curriesLeft=Op1000 has 3 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1001 o8=9 curriesLeft=Op1001 has 3 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1010 o8=10 curriesLeft=Op1010 has 3 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1011 o8=11 curriesLeft=Op1011 has 3 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1100 o8=12 curriesLeft=Op1100 has 3 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1101 o8=13 curriesLeft=Op1101 has 3 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1110 o8=14 curriesLeft=Op1110 has 3 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1111 o8=15 curriesLeft=Op1111 has 3 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op10000 o8=16 curriesLeft=Op10000 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op10001 o8=17 curriesLeft=Op10001 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op10010 o8=18 curriesLeft=Op10010 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op10011 o8=19 curriesLeft=Op10011 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op10100 o8=20 curriesLeft=Op10100 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op10101 o8=21 curriesLeft=Op10101 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op10110 o8=22 curriesLeft=Op10110 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op10111 o8=23 curriesLeft=Op10111 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op11000 o8=24 curriesLeft=Op11000 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op11001 o8=25 curriesLeft=Op11001 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op11010 o8=26 curriesLeft=Op11010 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op11011 o8=27 curriesLeft=Op11011 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op11100 o8=28 curriesLeft=Op11100 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op11101 o8=29 curriesLeft=Op11101 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op11110 o8=30 curriesLeft=Op11110 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op11111 o8=31 curriesLeft=Op11111 has 4 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op100000 o8=32 curriesLeft=Op100000 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op100001 o8=33 curriesLeft=Op100001 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op100010 o8=34 curriesLeft=Op100010 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op100011 o8=35 curriesLeft=Op100011 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op100100 o8=36 curriesLeft=Op100100 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op100101 o8=37 curriesLeft=Op100101 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op100110 o8=38 curriesLeft=Op100110 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op100111 o8=39 curriesLeft=Op100111 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op101000 o8=40 curriesLeft=Op101000 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op101001 o8=41 curriesLeft=Op101001 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op101010 o8=42 curriesLeft=Op101010 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op101011 o8=43 curriesLeft=Op101011 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op101100 o8=44 curriesLeft=Op101100 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op101101 o8=45 curriesLeft=Op101101 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op101110 o8=46 curriesLeft=Op101110 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op101111 o8=47 curriesLeft=Op101111 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op110000 o8=48 curriesLeft=Op110000 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op110001 o8=49 curriesLeft=Op110001 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op110010 o8=50 curriesLeft=Op110010 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op110011 o8=51 curriesLeft=Op110011 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op110100 o8=52 curriesLeft=Op110100 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op110101 o8=53 curriesLeft=Op110101 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op110110 o8=54 curriesLeft=Op110110 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op110111 o8=55 curriesLeft=Op110111 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op111000 o8=56 curriesLeft=Op111000 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op111001 o8=57 curriesLeft=Op111001 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op111010 o8=58 curriesLeft=Op111010 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op111011 o8=59 curriesLeft=Op111011 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op111100 o8=60 curriesLeft=Op111100 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op111101 o8=61 curriesLeft=Op111101 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op111110 o8=62 curriesLeft=Op111110 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op111111 o8=63 curriesLeft=Op111111 has 5 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1000000 o8=64 curriesLeft=Op1000000 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1000001 o8=65 curriesLeft=Op1000001 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1000010 o8=66 curriesLeft=Op1000010 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1000011 o8=67 curriesLeft=Op1000011 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1000100 o8=68 curriesLeft=Op1000100 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1000101 o8=69 curriesLeft=Op1000101 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1000110 o8=70 curriesLeft=Op1000110 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1000111 o8=71 curriesLeft=Op1000111 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1001000 o8=72 curriesLeft=Op1001000 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1001001 o8=73 curriesLeft=Op1001001 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1001010 o8=74 curriesLeft=Op1001010 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1001011 o8=75 curriesLeft=Op1001011 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1001100 o8=76 curriesLeft=Op1001100 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1001101 o8=77 curriesLeft=Op1001101 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1001110 o8=78 curriesLeft=Op1001110 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1001111 o8=79 curriesLeft=Op1001111 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1010000 o8=80 curriesLeft=Op1010000 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1010001 o8=81 curriesLeft=Op1010001 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1010010 o8=82 curriesLeft=Op1010010 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1010011 o8=83 curriesLeft=Op1010011 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1010100 o8=84 curriesLeft=Op1010100 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1010101 o8=85 curriesLeft=Op1010101 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1010110 o8=86 curriesLeft=Op1010110 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1010111 o8=87 curriesLeft=Op1010111 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1011000 o8=88 curriesLeft=Op1011000 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1011001 o8=89 curriesLeft=Op1011001 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1011010 o8=90 curriesLeft=Op1011010 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1011011 o8=91 curriesLeft=Op1011011 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1011100 o8=92 curriesLeft=Op1011100 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1011101 o8=93 curriesLeft=Op1011101 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1011110 o8=94 curriesLeft=Op1011110 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1011111 o8=95 curriesLeft=Op1011111 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1100000 o8=96 curriesLeft=Op1100000 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1100001 o8=97 curriesLeft=Op1100001 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1100010 o8=98 curriesLeft=Op1100010 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1100011 o8=99 curriesLeft=Op1100011 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1100100 o8=100 curriesLeft=Op1100100 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1100101 o8=101 curriesLeft=Op1100101 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1100110 o8=102 curriesLeft=Op1100110 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1100111 o8=103 curriesLeft=Op1100111 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1101000 o8=104 curriesLeft=Op1101000 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1101001 o8=105 curriesLeft=Op1101001 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1101010 o8=106 curriesLeft=Op1101010 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1101011 o8=107 curriesLeft=Op1101011 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1101100 o8=108 curriesLeft=Op1101100 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1101101 o8=109 curriesLeft=Op1101101 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1101110 o8=110 curriesLeft=Op1101110 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1101111 o8=111 curriesLeft=Op1101111 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1110000 o8=112 curriesLeft=Op1110000 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1110001 o8=113 curriesLeft=Op1110001 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1110010 o8=114 curriesLeft=Op1110010 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1110011 o8=115 curriesLeft=Op1110011 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1110100 o8=116 curriesLeft=Op1110100 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1110101 o8=117 curriesLeft=Op1110101 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1110110 o8=118 curriesLeft=Op1110110 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1110111 o8=119 curriesLeft=Op1110111 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1111000 o8=120 curriesLeft=Op1111000 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1111001 o8=121 curriesLeft=Op1111001 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1111010 o8=122 curriesLeft=Op1111010 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1111011 o8=123 curriesLeft=Op1111011 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1111100 o8=124 curriesLeft=Op1111100 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1111101 o8=125 curriesLeft=Op1111101 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1111110 o8=126 curriesLeft=Op1111110 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op Op1111111 o8=127 curriesLeft=Op1111111 has 6 params. Op is known at 7 params, and is copied from left child after that. description: undefined
​ Add op F o8=128 curriesLeft=2 description: the church-false lambda aka Î»y.Î»z.z. (f u) is identityFunc. To keep closing the quine loop simple, identityFunc is (u u u u u u u u u) aka (f u), but technically (u u u u u u u u anything) is also an identityFunc since (f anything x)->x. (l u)->(u u u u u u u u u). (r u)->u. (l u (r u))->u, the same way (l anythingX (r anythingX))->anythingX forall halted lambda anythingX.
​ Add op T o8=129 curriesLeft=2 description: the church-true lambda and the k lambda of SKI-Calculus, aka Î»y.Î»z.y
​ Add op bit0 o8=130 curriesLeft=248 description: complete binary tree is made of pow(2,cbtHeight) number of bit0 and bit1, evals at each curry, and counts rawCurriesLeft down to store (log2 of) cbt size
​ Add op Bit1 o8=131 curriesLeft=248 description: see bit0
​ Add op L o8=132 curriesLeft=1 description: get left/func child. Forall x, (l x (r x)) equals x, including that (l u) is identityFunc and (r u) is u.
​ Add op R o8=133 curriesLeft=get right/param child. Forall x, (l x (r x)) equals x, including that (l u) is identityFunc and (r u) is u. description: undefined
​ Add op Isleaf o8=134 curriesLeft=1 description: returns t or f of is its param u aka the universal lambda
​ Add op IsClean o8=135 curriesLeft=1 description: the 2x2 kinds of clean/dirty/etc. exists only on stack. only with both isClean and isAllowSinTanhSqrtRoundoffEtc at once, is it deterministic. todo reverse order aka call it !isDirty instead of isClean?
​ Add op IsAllowSinTanhSqrtRoundoffEtc o8=136 curriesLeft=1 description: the 2x2 kinds of clean/dirty/etc. exists only on stack. only with both isClean and isAllowSinTanhSqrtRoundoffEtc at once, is it deterministic. todo reverse order?
​ Add op Lambda o8=137 curriesLeft=2 description: FIXME this will take varsize list [(streamGet varName) (streamGet otherVar) ...] and a funcBody (or is funcBody before that param) then that varsize list (up to max around 250-something params (or is it 120-something params?) then call funcBody similaar to described below (except maybe use [allParamsExceptLast lastParam] instead of (pair allParamsExceptLast lastParam)) FIXME TODO the streamGet op should work on that datastruct that funcBody gets as param, so (streamGet otherVar [allParamsExceptLast lastParam])-> val of otherVar in the param list of lambda op. OLD... Takes just funcBody and 1 more param, but using opOneMoreParam (the only vararg op) with a (lambda...) as its param, can have up to (around, TODO) undefined params including that funcBody is 8th param of u. (lambda funcBody ?? a b ??? c d e) -> (funcBody (pair (lambda funcBody ?? a b ??? c d) e)). It might be, Im trying to make it consistent, that funcBody is always param 8 in lambda and varargAx. (opOneMoreParam aVarName aLambda ...moreParams...).
​ Add op GetVarFn o8=138 curriesLeft=2 description: theres 4 things in stream [x valXLambda valXDoubleRaw valXDoubleArrayRaw y val val val z val val val ...], 3 of which are vals. FIXME choose 3 prefix chars such as ?x _x /x. Rewrite this comment... so, ddee? would be a syntax for (getnamedparam "ddee").
​ Add op GetVarDouble o8=139 curriesLeft=2 description: theres 4 things in stream [x valXLambda valXDoubleRaw valXDoubleArrayRaw y val val val z val val val ...], 3 of which are vals. FIXME choose 3 prefix chars such as ?x _x /x. Rewrite this comment... so, ddee? would be a syntax for (getnamedparam "ddee").
​ Add op GetVarDoubles o8=140 curriesLeft=2 description: theres 4 things in stream [x valXLambda valXDoubleRaw valXDoubleArrayRaw y val val val z val val val ...], 3 of which are vals. FIXME choose 3 prefix chars such as ?x _x /x. Rewrite this comment... so, ddee? would be a syntax for (getnamedparam "ddee").
​ Add op VarargAx o8=141 curriesLeft=2 description: FIXME varargAx has strange behaviors about curriesLeft and verifying it and halted vs evaling. Its 2 params at first but after that it keeps extending it by 1 more param, after verifying the last param and choosing to be halted or eval at each next param. That design might change the number of params to simplify things, so careful in building on this op yet. I set it to 2 params so that after the first 7 params it waits until 9 params to eval, and after that it evals on every next param.
​ Add op S o8=142 curriesLeft=3 description: For control-flow. the s lambda of SKI-Calculus, aka Î»x.Î»y.Î»z.xz(yz)
​ Add op Pair o8=143 curriesLeft=3 description: the church-pair lambda aka Î»x.Î»y.Î»z.zxy
​ Add op Infcur o8=144 curriesLeft=255 description: like a linkedlist but not made of pairs. just keep calling it on more params and it will be instantly halted.
​ Add op Mut o8=145 curriesLeft=6 description: Used with opmut* and lambdaParams*. This is a snapshot of a key/fourVals, normally used in a [...] stream/infcur. (Mut cbtNotNecessarilyDeduped doubleThatIsOrWillBeDeduped fnThatIsOrWillBeDeduped fnNotNecessarilyDeduped fnAsKeyThatIsOrWillBeDeduped) is halted, and add 1 more param and it infloops). FIXME should Mut be a little varargAx-like as it could verify its params are those types (but unlike varargAx, guarantees it verifies fast)?
​ Add op OpmutOuter o8=146 curriesLeft=2 description: (opmutOuter treeOfJavascriptlikeCode param), and treeOfJavascriptlikeCode can call opmutInner which is like opmutOuter except it doesnt restart the mutable state, and each opmutInner may be compiled (to evaler) separately so you can reuse different combos of them without recompiling each, just recompiling (or not) the opmutOuter andOr multiple levels of opmutInner in opmutInner. A usecase for this is puredata-like pieces of musical instruments that can be combined and shared in realtime across internet.
​ Add op OpmutInner o8=147 curriesLeft=2 description: See opmutOuter. Starts at a Mut inside the one opmutOuter can reach, so its up to the outer opmuts if that Mut contains pointers to Muts it otherwise wouldnt be able to access.
​ Add op StackIsAllowstackTimestackMem o8=148 curriesLeft=1 description: reads a certain bit (stackIsAllowstackTimestackMem) from top of stack, part of the recursively-tightenable-higher-on-stack permissions system
​ Add op StackIsAllowNondetRoundoff o8=149 curriesLeft=1 description: reads a certain bit (stackIsAllowNondetRoundoff) from top of stack, part of the recursively-tightenable-higher-on-stack permissions system
​ Add op StackIsAllowMutableWrapperLambdaAndSolve o8=150 curriesLeft=1 description: reads a certain bit (stackIsAllowMutableWrapperLambdaAndSolve) from top of stack, part of the recursively-tightenable-higher-on-stack permissions system
​ Add op StackIsAllowAx o8=151 curriesLeft=1 description: reads a certain bit (stackIsAllowAx) from top of stack, part of the recursively-tightenable-higher-on-stack permissions system
​ Add op IsCbt o8=152 curriesLeft=1 description: returns t or f, is the param a cbt aka complete binary tree of bit0 and bit1
​ Add op ContainsAxConstraint o8=153 curriesLeft=1 description: returns t or f, does the param contain anything that implies any lambda call has halted aka may require infinite time and memory (the simplest way, though sometimes it can be done as finite) to verify
​ Add op Dplusraw o8=154 curriesLeft=2 description: raw means just the bits, not wrapped in a typeval. add to doubles/float64s to get a float64, or if in that op that allows reduced precision to float32 (such as in gpu.js) then that, but the result is still abstractly a double, just has less precision, and in gpujs would still be float32s during middle calculations.
​ Add op StreamGet o8=155 curriesLeft=2 description: FIXME theres 3 vals per key, not just 1. Merge this with GetVarFn GetVarDouble and GetVarDoubles. OLD... Reads a streaming map. Uses an infcur/[...] as a map, thats a stream-appendable (by forkEdit, still immutable) list of key val key val. It does linear search in the simplest implementation but opmut is being replaced by streamGet and streamPut etc which will have a Node.evaler optimization to compile combos of streamGet and streamPut and For While + * / Math.sin Math.exp etc... compile that to javascript code (still cant escape sandbox or cause infinite loops outside the stackTime stackMem etd (gas*) system, and in some cases compile it to GPU (such as using GPU.js or Lazycl). (streamGet keyB [keyB otherVal keyA valA keyB valB keyC valC])->valB, or ->u if there is no valB. [...] means (infcur ...). From the right end, looks left until finds the given key, and returns the val for it, or if reaches infcur before finding the key, then returns u. [...] is variable size. ([...] x)->[... x], so do that twice to append a key and val. Same key can be updated multiple times, statelessly. Equality of keys is by content/forestShape (see equals op). Vals arent checked for equality so you can use lazyDedup such as wrapping a large Float64Array or Float32Array or Int32Array (maybe only of powOf2 size or maybe bize and blobFrom and blobTo var can handle non-powOf2?) in a Node.
​ Add op StreamPut o8=156 curriesLeft=2 description: Writes a streaming map. See streamGet. (streamPut keyB someVal [keyA valA keyB valB keyA anotherVal])->[keyA valA keyB valB keyA anotherVal keyB someVal]
​ Add op StreamPack o8=157 curriesLeft=1 description: ForkEdits a [...] to only have the last val for each key. You would do this after writing a bunch of key/vals to it, each key written 1 to many times. For example, just a simple loop of a var from 0 to a million would create a [] of size 2 million, but streamPack it during that or at the end and its just size 2. When Evaler optimized it wont even create the [...] in the middle steps. (streamPack [keyA valA keyB valB keyA anotherVal])->[keyB valB keyA anotherVal].
​ Add op Get32BitsInCbt o8=158 curriesLeft=2 description: (get32BitsInCbt cbtOf32BitBlocks cbt32Index)->cbt32Val
​ Add op Put32BitsInCbt o8=159 curriesLeft=3 description: (put32BitsInCbt cbtOf32BitBlocks cbt32Index cbt32Val)->forkEdited_cbtOf32BitBlocks
​ Add op Equals o8=160 curriesLeft=2 description: By content/forestShape of 2 params. This op could be derived using s, t, l, r, and isLeaf. implementationDetailOfThePrototypeVM(((If a node doesnt contain a blob such as Int32Array (which is just an optimization of bit0 and bit1 ops) then its id64 (Node.idA and Node.idB, together are id64, and blobFrom and blobTo would both be 0 in that case, which is normally id128) is its unique id in that VM. Maybe there will be a range in that id64 to mean blobFrom and blobTo are both 0 aka does not contain a blob.))).
​ Add op StreamWhile o8=161 curriesLeft=3 description: (streamWhile condition loopBody stream) is like, if you wrote it in javascript: while(condition(stream)) stream = loopBody(stream); return stream;
​ Add op StreamDoWhile o8=162 curriesLeft=3 description: (streamDoWhile loopBody condition stream) is like, if you wrote it in javascript: do{ stream = loopBody(stream); }while(condition(stream)); return stream; 
​ Add op StreamFor o8=163 curriesLeft=5 description: (streamFor start condition afterLoopBody loopBody stream) is like, if you wrote it in javascript: for(stream = start(stream); condition(stream); stream = afterLoopBody(stream)) stream = loopBody(stream); return stream;
​ Add op IfElse o8=164 curriesLeft=4 description: (ifElse condition ifTrue ifFalse state) is like, if you wrote it in javascript: ((condition(state) ? ifTrue : ifFalse)(state)).
​ Add op If o8=165 curriesLeft=3 description: (if condition ifTrue state) is like, if you wrote it in javascript: (condition(state) ? ifTrue(state) : state).
​ Add op GetSalt128 o8=166 curriesLeft=1 description: (getSalt128 ignore)->the cbt128 of salt thats at top of stack aka 3-way-lambda-call of salt128 func and param.
​ Add op WithSalt128 o8=167 curriesLeft=3 description: (withSalt128 cbt128 func param)-> (func param) except with that cbt128 pushed onto the salt stack. During that, getSalt128 will get that cbt128.
​ Add op WithSalt128TransformedBy o8=168 curriesLeft=1 description: (withSalt128TransformedBy funcOf128BitsTo128Bits func param)-> same as (withSalt128 (funcOf128BitsTo128Bits (getSalt128 u)) func param).
​ Add op SolveRecog o8=169 curriesLeft=1 description: (solveRecog x) -> any y where (x y) halts, preferring those that use less compute resources (stackTime stackMem etc) but THIS IS NONDETERMINISTIC so can only be used while stackIsAllowMutableWrapperLambdaAndSolve is true on stack. This is for bit what solveFloat64 is for double/float64.
​ Add op SolveFloat64 o8=170 curriesLeft=1 description: (solveFloat64 x) -> any y where (x y)->float64 (todo is the float64 the raw 64 bits or is it wrapped in a typeval or a typevalDouble etc?), where the float64 is positive, and the higher the better. Requiring positive makes it able to emulate solveRecog. The higher the better, makes it a goal function. Like solveRecog, THIS IS NONDETERMINISTIC so can only be used while stackIsAllowMutableWrapperLambdaAndSolve is true on stack.
​ Add op Bize31 o8=171 curriesLeft=1 description: (bize31 x) -> cbt32, the low 31 bits of the index of the last (op) bit1, if its a cbt, else 0 if its not a cbt or does not contain any bit1. Bize means bitstring size (in bits). Max bitstring size is around 2^247-1 bits (todo find exact number).
​ Add op Bize53 o8=172 curriesLeft=1 description: (bize53 x) -> cbt64, the low 53 (so it can be stored in a double) bits of bize. See bize32 comment for what is bize in general.
​ Add op Bize256 o8=173 curriesLeft=1 description: (bize256 x) -> cbt256. See bize32 comment for what is bize in general. This always fits in a 256 bit literal that is its own id.
​ Add op LambdaParamsList o8=174 curriesLeft=1 description: From any number of curries (such as waiting on 3 more params in this: (Lambda FuncBody [w x y z] 100), or from the (LazyEval (Lambda... allParamsExceptLast) lastParam) if it has all its params which FuncBody is called on), gets the whole [w x y z], or gets [] if its not 1 of those datastructs. [...] is infcur syntax.
​ Add op LambdaParamsStream o8=175 curriesLeft=1 description: FIXME this should return a [(Mut...) (Mut...) (Mut...)]. FIXME see comments at top of this js file, about [...] of "[cbtNotNecessarilyDeduped doubleThatIsOrWillBeDeduped fnThatIsOrWillBeDeduped fnNotNecessarilyDeduped fnAsKeyThatIsOrWillBeDeduped]" as snapshot of Mut. Used with (Lambda FuncBody [x y z] valX valY valZ) -> (FuncBody (LazyEval (opLambda FuncBody [x y z] valX valY) valZ)). Returns [x valXLambda valXDoubleRaw valXDoubleArrayRaw y val val val z val val val], in blocks of those 4 things, which is used with Opmut/For/While/etc.
​ Add op Seq o8=176 curriesLeft=2 description: The _ in (_[a b c] x) means ((Seq [a b c]) x) which does (c (b (a x))), for any vararg in the [].
​ Add op HasMoreThan7Params o8=177 curriesLeft=1 description: op is known at 7 params, so thats sometimes used as end of a list, especially in an infcur list.
​ Add op Op178ReservedForFutureExpansionAndInfloopsForNow o8=178 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op179ReservedForFutureExpansionAndInfloopsForNow o8=179 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op180ReservedForFutureExpansionAndInfloopsForNow o8=180 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op181ReservedForFutureExpansionAndInfloopsForNow o8=181 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op182ReservedForFutureExpansionAndInfloopsForNow o8=182 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op183ReservedForFutureExpansionAndInfloopsForNow o8=183 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op184ReservedForFutureExpansionAndInfloopsForNow o8=184 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op185ReservedForFutureExpansionAndInfloopsForNow o8=185 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op186ReservedForFutureExpansionAndInfloopsForNow o8=186 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op187ReservedForFutureExpansionAndInfloopsForNow o8=187 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op188ReservedForFutureExpansionAndInfloopsForNow o8=188 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op189ReservedForFutureExpansionAndInfloopsForNow o8=189 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op190ReservedForFutureExpansionAndInfloopsForNow o8=190 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op191ReservedForFutureExpansionAndInfloopsForNow o8=191 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op192ReservedForFutureExpansionAndInfloopsForNow o8=192 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op193ReservedForFutureExpansionAndInfloopsForNow o8=193 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op194ReservedForFutureExpansionAndInfloopsForNow o8=194 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op195ReservedForFutureExpansionAndInfloopsForNow o8=195 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op196ReservedForFutureExpansionAndInfloopsForNow o8=196 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op197ReservedForFutureExpansionAndInfloopsForNow o8=197 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op198ReservedForFutureExpansionAndInfloopsForNow o8=198 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op199ReservedForFutureExpansionAndInfloopsForNow o8=199 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op200ReservedForFutureExpansionAndInfloopsForNow o8=200 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op201ReservedForFutureExpansionAndInfloopsForNow o8=201 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op202ReservedForFutureExpansionAndInfloopsForNow o8=202 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op203ReservedForFutureExpansionAndInfloopsForNow o8=203 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op204ReservedForFutureExpansionAndInfloopsForNow o8=204 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op205ReservedForFutureExpansionAndInfloopsForNow o8=205 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op206ReservedForFutureExpansionAndInfloopsForNow o8=206 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op207ReservedForFutureExpansionAndInfloopsForNow o8=207 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op208ReservedForFutureExpansionAndInfloopsForNow o8=208 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op209ReservedForFutureExpansionAndInfloopsForNow o8=209 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op210ReservedForFutureExpansionAndInfloopsForNow o8=210 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op211ReservedForFutureExpansionAndInfloopsForNow o8=211 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op212ReservedForFutureExpansionAndInfloopsForNow o8=212 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op213ReservedForFutureExpansionAndInfloopsForNow o8=213 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op214ReservedForFutureExpansionAndInfloopsForNow o8=214 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op215ReservedForFutureExpansionAndInfloopsForNow o8=215 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op216ReservedForFutureExpansionAndInfloopsForNow o8=216 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op217ReservedForFutureExpansionAndInfloopsForNow o8=217 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op218ReservedForFutureExpansionAndInfloopsForNow o8=218 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op219ReservedForFutureExpansionAndInfloopsForNow o8=219 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op220ReservedForFutureExpansionAndInfloopsForNow o8=220 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op221ReservedForFutureExpansionAndInfloopsForNow o8=221 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op222ReservedForFutureExpansionAndInfloopsForNow o8=222 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op223ReservedForFutureExpansionAndInfloopsForNow o8=223 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op224ReservedForFutureExpansionAndInfloopsForNow o8=224 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op225ReservedForFutureExpansionAndInfloopsForNow o8=225 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op226ReservedForFutureExpansionAndInfloopsForNow o8=226 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op227ReservedForFutureExpansionAndInfloopsForNow o8=227 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op228ReservedForFutureExpansionAndInfloopsForNow o8=228 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op229ReservedForFutureExpansionAndInfloopsForNow o8=229 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op230ReservedForFutureExpansionAndInfloopsForNow o8=230 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op231ReservedForFutureExpansionAndInfloopsForNow o8=231 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op232ReservedForFutureExpansionAndInfloopsForNow o8=232 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op233ReservedForFutureExpansionAndInfloopsForNow o8=233 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op234ReservedForFutureExpansionAndInfloopsForNow o8=234 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op235ReservedForFutureExpansionAndInfloopsForNow o8=235 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op236ReservedForFutureExpansionAndInfloopsForNow o8=236 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op237ReservedForFutureExpansionAndInfloopsForNow o8=237 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op238ReservedForFutureExpansionAndInfloopsForNow o8=238 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op239ReservedForFutureExpansionAndInfloopsForNow o8=239 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op240ReservedForFutureExpansionAndInfloopsForNow o8=240 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op241ReservedForFutureExpansionAndInfloopsForNow o8=241 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op242ReservedForFutureExpansionAndInfloopsForNow o8=242 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op243ReservedForFutureExpansionAndInfloopsForNow o8=243 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op244ReservedForFutureExpansionAndInfloopsForNow o8=244 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op245ReservedForFutureExpansionAndInfloopsForNow o8=245 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op246ReservedForFutureExpansionAndInfloopsForNow o8=246 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op247ReservedForFutureExpansionAndInfloopsForNow o8=247 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op248ReservedForFutureExpansionAndInfloopsForNow o8=248 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op249ReservedForFutureExpansionAndInfloopsForNow o8=249 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op250ReservedForFutureExpansionAndInfloopsForNow o8=250 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op251ReservedForFutureExpansionAndInfloopsForNow o8=251 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op252ReservedForFutureExpansionAndInfloopsForNow o8=252 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op253ReservedForFutureExpansionAndInfloopsForNow o8=253 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op254ReservedForFutureExpansionAndInfloopsForNow o8=254 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Add op Op255ReservedForFutureExpansionAndInfloopsForNow o8=255 curriesLeft=Given 1 param, evals to (S I I (S I I)) aka the simplest infinite loop, so later if its replaced by another op (is reserved for future expansion) then the old and new code will never have 2 different return values for the same lambda call (except if on the stack the 4 kinds of clean/dirty (stackIsAllowstackTimestackMem stackIsAllowNondetRoundoff stackIsAllowMutableWrapperLambdaAndSolve stackIsAllowAx) allow nondeterminism which if theyre all clean then its completely deterministic and theres never more than 1 unique return value for the same lambda call done again. description: undefined
​ Evaling l=u r=u
​ Evaling l=F r=u
​ Evaling l=L r=u
​ Test pass: tie the quine knot, both equal F(u)
​ Evaling l=F r=u
​ Test pass: tie the quine knot 2, both equal F(u)
​ Evaling l=L r=u
​ Evaling l=u r=u
​ Evaling l=Op10 r=u
​ Evaling l=Op100 r=u
​ Evaling l=Op1000 r=u
​ Evaling l=Op10000 r=u
​ Evaling l=Op100000 r=u
​ Evaling l=Op1000000 r=u
​ Evaling l=F r=u
​ Test pass: tie the quine knot 3, both equal F(u)
​ Evaling l=R r=u
​ Test pass: tie the quine knot 4, both equal u
​ Evaling l=L r=u
​ Evaling l=R r=u
​ Evaling l=F(u) r=u
​ Test pass: tie the quine knot 5 aka l(x)(r(x)) equals x, for any x (in this case x is u), both equal u
​ Test pass: tie the quine knot 6, both equal 0
​ Test pass: tie the quine knot 7, both equal 0
​ Test pass: tie the quine knot 8, both equal 0
​ Test pass: tie the quine knot 9, both equal 0
​ Test pass: tie the quine knot 10, both equal 1
​ Evaling l=L r=u
​ Evaling l=R r=u
​ Test pass: tie the quine knot 11, both equal 1
​ Evaling l=L r=S
​ Evaling l=R r=S
​ Evaling l=Op1000111 r=u
​ Test pass: l(x)(r(x)) equals x, for any x (in this case x is s), both equal S
​ Evaling l=L r=L
​ Evaling l=R r=L
​ Evaling l=Op1000010 r=u
​ Test pass: l(x)(r(x)) equals x, for any x (in this case x is l), both equal L
​ Evaling l=L r=R
​ Evaling l=R r=R
​ Evaling l=Op1000010 r=Op10
​ Test pass: l(x)(r(x)) equals x, for any x (in this case x is r), both equal R
​ Evaling l=S r=T
​ Evaling l=S(T) r=T
​ Evaling l=S(T)(T) r=L
2​ Evaling l=T r=L
​ Evaling l=T(L) r=T(L)
​ Test pass: s(t)(t)(l) which should be an identityFunc, both equal L
​ Evaling l=S r=T
​ Evaling l=S(T) r=T
​ Evaling l=S r=T
​ Evaling l=S(T) r=T
​ Test pass: check dedup of s(t)(t), both equal S(T)(T)
​ Evaling l=S r=T
​ Evaling l=S(T) r=T
​ Evaling l=S r=T
​ Evaling l=S(T) r=T
​ Evaling l=S(T)(T) r=S(T)(T)
2​ Evaling l=T r=S(T)(T)
​ Evaling l=T(S(T)(T)) r=T(S(T)(T))
​ Evaling l=S r=T
​ Evaling l=S(T) r=T
​ Test pass: s(t)(t) called on itself returns itself since its an identityFunc, both equal S(T)(T)
​ Test pass: o8/opcode of u, both equal 1
​ Evaling l=u r=u
​ Test pass: o8/opcode of u(u), both equal 2
2​ Evaling l=u r=u
​ Test pass: check dedup of u(u), both equal Op10
​ Evaling l=u r=u
​ Evaling l=u r=Op10
​ Test pass: o8/opcode of u(uu), both equal 3
​ Evaling l=u r=Op10
​ Evaling l=Op11 r=Op10
​ Evaling l=Op111 r=Op10
​ Evaling l=Op1111 r=Op10
​ Evaling l=Op11111 r=u
​ Evaling l=Op111110 r=Op10
​ Test pass: o8/opcode of u(uu)(uu)(uu)(uu)(u)(uu)().o8(), both equal 125
​ Evaling l=u r=Op10
​ Evaling l=Op11 r=Op10
​ Evaling l=Op111 r=Op10
​ Evaling l=Op1111 r=Op10
​ Evaling l=Op11111 r=Op10
​ Evaling l=Op111111 r=Op10
​ Test pass: o8/opcode of u(uu)(uu)(uu)(uu)(uu)(uu), both equal 127
​ Evaling l=L r=L
​ Evaling l=R r=L
​ Evaling l=Op1000010 r=u
​ Evaling l=L r=S
​ Evaling l=L r=R
​ Evaling l=R r=R
​ Evaling l=Op1000010 r=Op10
​ Evaling l=R r=S
​ Evaling l=Op1000111 r=u
​ Test pass: (l x (r x)) equals x forall x, deeper, both equal S
​ Evaling l=L r=L
​ Evaling l=R r=L
​ Evaling l=Op1000010 r=u
​ Evaling l=Pair r=S
​ Evaling l=Pair(S) r=L
​ Evaling l=L r=Pair(S)(L)
​ Evaling l=L r=R
​ Evaling l=R r=R
​ Evaling l=Op1000010 r=Op10
​ Evaling l=Pair r=S
​ Evaling l=Pair(S) r=L
​ Evaling l=R r=Pair(S)(L)
​ Evaling l=Pair(S) r=L
​ Evaling l=Pair r=S
​ Evaling l=Pair(S) r=L
​ Test pass: (l x (r x)) equals x forall x, deeper 2, both equal Pair(S)(L)
​ Evaling l=S r=F(u)
​ Evaling l=S(F(u)) r=F(u)
​ Evaling l=S(F(u))(F(u)) r=Pair
2​ Evaling l=F(u) r=Pair
2​ Evaling l=Pair r=Pair
​ Test pass: callParamOnItself(pair)->pair(pair), both equal Pair(Pair)
​ Evaling l=S r=F(u)
​ Evaling l=S r=T
​ Evaling l=S(T) r=T
​ Evaling l=S(F(u)) r=S(T)(T)
​ Evaling l=S(F(u))(S(T)(T)) r=Pair
​ Evaling l=F(u) r=Pair
​ Evaling l=S(T)(T) r=Pair
2​ Evaling l=T r=Pair
​ Evaling l=T(Pair) r=T(Pair)
2​ Evaling l=Pair r=Pair
​ Test pass: callParamOnItself(pair)->pair(pair) 2 different identityFuncs, both equal Pair(Pair)
​ Script ended. wikibinator203 = u which is the universal combinator/lambda you can build anything with.
​ Script (near) ending. wikibinator203 = u
8​ 
​ wikibinator203...
​ wikibinator203 = u
​ Evaling l=u r=u
​ uu = Op10
​ Creating var: u
​ Creating var: Op10
​ Creating var: Op11
​ Creating var: Op100
​ Creating var: Op101
​ Creating var: Op110
​ Creating var: Op111
​ Creating var: Op1000
​ Creating var: Op1001
​ Creating var: Op1010
​ Creating var: Op1011
​ Creating var: Op1100
​ Creating var: Op1101
​ Creating var: Op1110
​ Creating var: Op1111
​ Creating var: Op10000
​ Creating var: Op10001
​ Creating var: Op10010
​ Creating var: Op10011
​ Creating var: Op10100
​ Creating var: Op10101
​ Creating var: Op10110
​ Creating var: Op10111
​ Creating var: Op11000
​ Creating var: Op11001
​ Creating var: Op11010
​ Creating var: Op11011
​ Creating var: Op11100
​ Creating var: Op11101
​ Creating var: Op11110
​ Creating var: Op11111
​ Creating var: Op100000
​ Creating var: Op100001
​ Creating var: Op100010
​ Creating var: Op100011
​ Creating var: Op100100
​ Creating var: Op100101
​ Creating var: Op100110
​ Creating var: Op100111
​ Creating var: Op101000
​ Creating var: Op101001
​ Creating var: Op101010
​ Creating var: Op101011
​ Creating var: Op101100
​ Creating var: Op101101
​ Creating var: Op101110
​ Creating var: Op101111
​ Creating var: Op110000
​ Creating var: Op110001
​ Creating var: Op110010
​ Creating var: Op110011
​ Creating var: Op110100
​ Creating var: Op110101
​ Creating var: Op110110
​ Creating var: Op110111
​ Creating var: Op111000
​ Creating var: Op111001
​ Creating var: Op111010
​ Creating var: Op111011
​ Creating var: Op111100
​ Creating var: Op111101
​ Creating var: Op111110
​ Creating var: Op111111
​ Creating var: Op1000000
​ Creating var: Op1000001
​ Creating var: Op1000010
​ Creating var: Op1000011
​ Creating var: Op1000100
​ Creating var: Op1000101
​ Creating var: Op1000110
​ Creating var: Op1000111
​ Creating var: Op1001000
​ Creating var: Op1001001
​ Creating var: Op1001010
​ Creating var: Op1001011
​ Creating var: Op1001100
​ Creating var: Op1001101
​ Creating var: Op1001110
​ Creating var: Op1001111
​ Creating var: Op1010000
​ Creating var: Op1010001
​ Creating var: Op1010010
​ Creating var: Op1010011
​ Creating var: Op1010100
​ Creating var: Op1010101
​ Creating var: Op1010110
​ Creating var: Op1010111
​ Creating var: Op1011000
​ Creating var: Op1011001
​ Creating var: Op1011010
​ Creating var: Op1011011
​ Creating var: Op1011100
​ Creating var: Op1011101
​ Creating var: Op1011110
​ Creating var: Op1011111
​ Creating var: Op1100000
​ Creating var: Op1100001
​ Creating var: Op1100010
​ Creating var: Op1100011
​ Creating var: Op1100100
​ Creating var: Op1100101
​ Creating var: Op1100110
​ Creating var: Op1100111
​ Creating var: Op1101000
​ Creating var: Op1101001
​ Creating var: Op1101010
​ Creating var: Op1101011
​ Creating var: Op1101100
​ Creating var: Op1101101
​ Creating var: Op1101110
​ Creating var: Op1101111
​ Creating var: Op1110000
​ Creating var: Op1110001
​ Creating var: Op1110010
​ Creating var: Op1110011
​ Creating var: Op1110100
​ Creating var: Op1110101
​ Creating var: Op1110110
​ Creating var: Op1110111
​ Creating var: Op1111000
​ Creating var: Op1111001
​ Creating var: Op1111010
​ Creating var: Op1111011
​ Creating var: Op1111100
​ Creating var: Op1111101
​ Creating var: Op1111110
​ Creating var: Op1111111
​ Creating var: F
​ Creating var: T
​ Creating var: bit0
​ Creating var: Bit1
​ Creating var: L
​ Creating var: R
​ Creating var: Isleaf
​ Creating var: IsClean
​ Creating var: IsAllowSinTanhSqrtRoundoffEtc
​ Creating var: Lambda
​ Creating var: GetVarFn
​ Creating var: GetVarDouble
​ Creating var: GetVarDoubles
​ Creating var: VarargAx
​ Creating var: S
​ Creating var: Pair
​ Creating var: Infcur
​ Creating var: Mut
​ Creating var: OpmutOuter
​ Creating var: OpmutInner
​ Creating var: StackIsAllowstackTimestackMem
​ Creating var: StackIsAllowNondetRoundoff
​ Creating var: StackIsAllowMutableWrapperLambdaAndSolve
​ Creating var: StackIsAllowAx
​ Creating var: IsCbt
​ Creating var: ContainsAxConstraint
​ Creating var: Dplusraw
​ Creating var: StreamGet
​ Creating var: StreamPut
​ Creating var: StreamPack
​ Creating var: Get32BitsInCbt
​ Creating var: Put32BitsInCbt
​ Creating var: Equals
​ Creating var: StreamWhile
​ Creating var: StreamDoWhile
​ Creating var: StreamFor
​ Creating var: IfElse
​ Creating var: If
​ Creating var: GetSalt128
​ Creating var: WithSalt128
​ Creating var: WithSalt128TransformedBy
​ Creating var: SolveRecog
​ Creating var: SolveFloat64
​ Creating var: Bize31
​ Creating var: Bize53
​ Creating var: Bize256
​ Creating var: LambdaParamsList
​ Creating var: LambdaParamsStream
​ Creating var: Seq
​ Creating var: HasMoreThan7Params
​ Creating var: Op178ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op179ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op180ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op181ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op182ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op183ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op184ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op185ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op186ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op187ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op188ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op189ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op190ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op191ReservedForFutureExpansionAndInfloopsForNow
​ Creating var: Op192ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op193ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op194ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op195ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op196ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op197ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op198ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op199ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op200ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op201ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op202ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op203ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op204ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op205ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op206ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op207ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op208ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op209ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op210ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op211ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op212ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op213ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op214ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op215ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op216ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op217ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op218ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op219ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op220ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op221ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op222ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op223ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op224ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op225ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op226ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op227ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op228ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op229ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op230ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op231ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op232ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op233ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op234ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op235ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op236ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op237ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op238ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op239ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op240ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op241ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op242ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op243ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op244ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op245ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op246ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op247ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op248ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op249ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op250ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op251ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op252ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op253ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op254ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:32 Creating var: Op255ReservedForFutureExpansionAndInfloopsForNow
testWikibinator203VM.html:34 T().o8() == 129
wikibinator203VM.js:3578 Evaling l=T r=Op10
wikibinator203VM.js:3578 Evaling l=T(Op10) r=u
''+S(T)(T)(L)
wikibinator203VM.js:3578 Evaling l=S r=T
wikibinator203VM.js:3578 Evaling l=S(T) r=T
wikibinator203VM.js:3578 Evaling l=S(T)(T) r=L
'L'
''+S(T)(T)(S(T))
wikibinator203VM.js:3578 Evaling l=S r=T
wikibinator203VM.js:3578 Evaling l=S(T) r=T
wikibinator203VM.js:3578 Evaling l=S r=T
wikibinator203VM.js:3578 Evaling l=S(T)(T) r=S(T)
wikibinator203VM.js:3578 Evaling l=T r=S(T)
wikibinator203VM.js:3578 Evaling l=T r=S(T)
wikibinator203VM.js:3578 Evaling l=T(S(T)) r=T(S(T))
'S(T)'