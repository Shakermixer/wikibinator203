<!DOCTYPE html><html><head>
<script src=Wikibinator203VM.js></script>
<script>

let U = Wikibinator203; //the universal function

let vm = Wikibinator203().vm;

var dom = id=>document.getElementById(id);

var h = '';

h += 'Wikibinator203='+Wikibinator203+' Push F12 to see some tests in browser console.';
h += '\n\n<br><br>In the ops list below, from vm.opInfo, you can use op name, such as S, T, Pair, (F U) is identityFunc, etc. Some ops arent working yet. More ops will be filled in later. This is early into the wikibinator203 prototype. Try it in the textareas. When you change text in the top textarea, it evals and puts the output into the bottom textarea, which you should be able to copy into the top textarea and edit more. This will be easier once these low level basics are worked out and you can do everything (TODO) by drag and drop across the internet with your friends in realtime.';
for(let op of vm.opInfo){
	 h += '\n\n<br><br>'+JSON.stringify(op);
}

window.onload = ()=>{
	dom('mainDiv').innerHTML = h;
	
	//let firstCode = '(S (F U) (F U) Pair)';
	//let firstCode = '[(CallParamOnItself#(S I#(F U) I) Pair) (CallParamOnItself F)]';
	let firstCode = '[(CallParamOnItself#(S I#(F U) I) Pair) (CallParamOnItself F) CallParamOnItself]';
	dom('codeIn').value = firstCode;
	evalTextAreas();
};

var evalTextAreas = ()=>{
	vm.refill();
	let textOut = 'ERROR';
	try{
		let wikibinator203CodeIn = dom('codeIn').value;
		if(dom('isEvalElseOnlyParse').checked){
			console.log('Eval');
			let fnOut = Eval(wikibinator203CodeIn);
			textOut = ''+fnOut;
		}else{
			console.log('Parse');
			let parseTree = Parse(wikibinator203CodeIn)
			textOut = ''+parseTree;
		}
	}catch(e){
		textOut = 'ERROR: '+e;
	}
	dom('codeOut').value = textOut;
};


var Eval = vm.eval; //of wikibinator203 code string -> fn. fn means a wikibinator203 lambda that is a javascript function of 1 param.

var lastParseTree = null;

var Parse = code=>(lastParseTree=vm.parse(code));

/*//TODO move this to a separate js file or the html file...

console.log('Script (near) ending. Wikibinator203 = '+Wikibinator203);
for(let i=0; i<8; i++) console.log('');

var U = Wikibinator203;


var vm = U().vm;


console.log('Wikibinator203...');

console.log('Wikibinator203 = '+Wikibinator203);

var UU = U(U);

console.log('UU = '+UU);


var ops = U().vm.ops;
for(name in ops){ console.log('Creating var: '+name); eval(name+' = ops.'+name); };

console.log('T().o8() == '+T().o8());
T(UU)(U);

console.log('\n\n\n\n\nS(S(T)(T))(T)  aka {T T T} = '+S(S(T)(T))(T)+'\n\n\n\n\n');

console.log('\n\n\n\n\nS(S(T)(S(L)(R)))(T) aka {T {L R} T} = '+S(S(T)(S(L)(R)))(T)+'\n\n\n\n\n');

console.log('\n\n\n\n\nT(T(Seq(S(S(T)(Pair))(T)))) = '+T(T(Seq(S(S(T)(Pair))(T))))+'\n\n\n\n\n');

console.log('\n\n\n\n\nPair(Pair(S)(S))(R) = '+Pair(Pair(S)(S))(R)+'\n\n\n\n\n');

console.log('\n\n\n\n\nInfcur(U)(U)(Infcur(T)) = '+Infcur(U)(U)(Infcur(T))+'\n\n\n\n\n');

console.log('\n\n\n\n\nSeq(Infcur(L)(R)(Seq(T(Seq(Pair))))) aka _[L R _,_Pair] = '+Seq(Infcur(L)(R)(Seq(T(Seq(Pair)))))+'\n\n\n\n\n');

console.log('starting basic tests of vm.eval:');

let wikibinator203Code = '_[L R _,_Pair]';
let evaledTo = vm.eval(wikibinator203Code);
if(evaledTo != Seq(Infcur(L)(R)(Seq(T(Seq(Pair)))))) throw 'Eval failed';

wikibinator203Code = '{T {L R} T}';
evaledTo = vm.eval(wikibinator203Code);
if(evaledTo != S(S(T)(S(L)(R)))(T)) throw 'Eval failed';

console.log('vm.eval passed basic tests.');
*/
	
</script>
</head><body>
<h1>Agree (no checkbox) to the opensource license at bottom of this file or dont use this. 
<br><br>
TODO TDD for Names# etc, but get the basics of parsing, eval, (Lambda [x y z] ...) MutLam, etc, working first.<br>
TODO I want ability to run most things in pure determinism mode (the cleanest). define all the primitive (especially double and int, maybe float, maybe byte, etc) ops, that both JVM and browser javascript (and maybe few other systems if can find overlapping bit behaviors) do deterministicly exactly the same as eachother, and use that as the deterministic definitions of the ops double*double double+double sine(double) etc. There must be an implementation of them made of U/TheUniversalLambda that doesnt depend on calling * + sine etc, Evaler optimized to use those if they exactly match. Careful to use final/const keyword(s) for order of ops and to prevent merging ops. Unlikely to match alot of them in GPU.js, but in lazycl it seems able to match what JVM does, for example. Some things will just have to be done in allownondeterministicroundoff (what was it called?) mode (a vm.mask_*) if want it fast enough such as teraflop graphics of 3d fractals etc. Also, for determinism, can only loop over Mut keys (as in MutLam etc), if sorted, but wrapper of Float64Array etc in Mut is int keys so thats not relevant there.<br>
TODO maybe an op for avl tree, or 2-way-trie, of 256 bit keys (generated by any fn as idMaker) and fn vals? Cuz need ability to map fn to fn, such as for Names# in a self-hosting code editor and will need it for a variety of things. Could derive it, and make an Evaler, but having an op for a basic kind of it might be good too. See addOp.<br>
TODO string literals when first letter is lowercase<br>
TODO cbt, partialDedup, and typeval<br>
TODO basic math ops including + * / sine of doubles and ints etc<br>
TODO Names#, just keep it in Node.localName andOr vm.Viewer vm.View etc, no lambda treemaps yet.<br>
TODO Names## syntax for commented func of 1 param, that op.<br>
TODO (Lambda [a b c] ...)<br>
TODO MutLam and compiling to js code<br>
TODO simple exeriments with voxel32<br>
TODO compiling to GPU.js code<br>
TODO tree of voxel32 with voxel32 offset per branch and cbt of n voxel32 per branch<br>
TODO webaudioapi, using MutLam to generate sound samples and read incoming microphone electric guitar etc<br>
TODO...<br>
</h1>
TODO at runtime when VM boots, and again after other libs may have been loaded after it, verify js String and Number etc dont have any of the fields im adding to Mut such as .d for doublearray and .m for map of string (generated by Mut.toString to be a globalid256 (which may be a literal string that fits in id, abbreved if its smaller)) to Mut_or_double, etc, for security since some lib might be designed so that when wikibinator203 and that lib are loaded at once, that wikibinator203's generated code would mistake (2+3).m for that, for example, which might break the VM andOr let it run any js code it wants in the browser instead of just code generated by the wikibinator203 VM.<br>
<br>
	<center>
		<h2>Test Wikibinator203 prototype (incomplete but works a little)</h2>
		Wikibinator203 code in. It evals while you type,<br> but until vm.stackTime and vm.stackMem are working,<br> you might have to close and reopen browser tab if you write an infinite loop).
		Example: (Pair (F U) S F) -> S<br>
		Example: (Pair (F U) S T) -> (F U)<br>
		Example: Pair -> Pair<br>
		Example: ([L R L R] Pair Pair L S R) -> [L R L R Pair Pair L S R]<br>
		Example: (L ([L R L R] Pair Pair L S R)) -> [L R L R Pair Pair L S]<br>
		Example: (R ([L R L R] Pair Pair L S R)) -> R<br>
		Example: (L U (R U)) -> U<br>
		Example: (L L (R L)) -> L<br>
		Example: (L R (R R)) -> R<br>
		Example: (L S (R S)) -> S<br>
		Example: (L (Pair S T) (R (Pair S T))) -> (Pair S T) - aka (Pair S T) is the iota lambda<br>
		Example: ((Pair S T) (Pair S T) [L R L R S]) -> [L R L R S] - cuz iota called on itself is an identityFunc.<br>
		Example: ((Pair S T) (Pair S T) (Pair S T)) -> (Pair S T) - cuz iota called on itself is an identityFunc.<br>
		Example: ((Pair S T) ((Pair S T) ((Pair S T) (Pair S T)))) -> T<br> - as in <a href=https://en.wikipedia.org/wiki/Iota_and_Jot>https://en.wikipedia.org/wiki/Iota_and_Jot</a> cuz T is the K of SKI-Calculus.<br>
		Example: ((Pair S T) ((Pair S T) ((Pair S T) ((Pair S T) (Pair S T))))) -> S<br> - as in <a href=https://en.wikipedia.org/wiki/Iota_and_Jot>https://en.wikipedia.org/wiki/Iota_and_Jot</a> cuz T is the K of SKI-Calculus.<br>
		This is an infinite loop (though runs out of javascript stack: (S (F U) (F U) (S (F U) (F U)))<br>
		[(CallParamOnItself#(S I#(F U) I) Pair) (CallParamOnItself F)] -> [(Pair Pair) (F F)] //TODO keep the Names#.<br>
		<b>It will be much easier use when Names#(...) and drag-and-drop and 1024x1024 per pixel graphics are working.</b><br>
		<br>
		Wikibinator203 code in.<br>
		<textarea id=codeIn rows="5" cols="100" oninput="evalTextAreas();"></textarea><br>
		Eval of the above code, out:<br>
		<textarea id=codeOut rows="5" cols="100" readonly></textarea><br>
		<input type=checkbox id=isEvalElseOnlyParse checked oninput="evalTextAreas();"></input><label for=isEvalElseOnlyParse>eval (else parse only)</label><br>
	</center>
	
	<a href=https://github.com/benrayfield/wikibinator203>https://github.com/benrayfield/wikibinator203</a><br>
	<a href=https://twitter.com/wikibinator>https://twitter.com/wikibinator</a><br>
	<br>
	
	<div id="mainDiv"></div>
	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	LICENSE AT TIME 2022-8-3 IS THIS BUT TODO COPY CHANGED LICENSE (BEFORE FINALIZING IT SOMEDAY) FROM LICENSE FILE WHEN CHANGED:[[[
Ben F Rayfield offers the wikibinator203 VM prototype, UI, and various tools, under this license
<br><br>
I (Ben F Rayfield) know this license is a mess and am planning to rewrite it to be much smaller,
divided into small paragraphs, move some parts to tutorials or other documents about the software,
and only keep the parts that arent strongly implied by the other parts.
Now that I've written about the "infinite size unweighted directed-graph with 3 edge-colors",
that seems an easier way to explain why it would cause problems for
specific people to own specific nodes and edges in that directed-graph,
and that nodes could be dangerous if copied into executable files outside the system, etc.
<br><br>
This license contains the 3 paragraphs of the MIT license and some extra copyleft stuff.
<br><br>
This is experimental software.
<br><br>
[THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.] (COPIED FROM LAST PARAGRAPH OF MIT LICENSE, APPLIES HERE)
<br><br>
This software uses a constant infinite size unweighted directed-graph
with 3 edge-colors, that contains all possible patterns of finite
amount of information that take finite amount of compute time and memory,
which an infinite number of subsets of it (if not the whole thing?)
are already near optimally compressed (near lowest kolmogorov complexity)
in its natural form. These edges are Func, Param, and EvalsTo,
where Func called on Param returns EvalsTo. Nobody owns that directed-graph
nor any nodes or edges in it,
nor the using of it as lambdas/wikibs (nodes are lambdas/wikibs).
Nobody owns wikibs. They are shared facts of maths many people and software
can use together. A wikib is a kind of number, stateless and immutable
(or approximations of it in some ways of using it)
universal lambda function, combinator, pattern-calculus function, fact of math,
a pure function, and a data structure that is defined completely as a forest
node with 2 child wikibs down to leaf (leaf also has 2 childs (identity
function and leaf)). Leaf (aka U aka Wikibinator203) is the universal
function, from which all turing-complete patterns of finite amount of
information can be built, used, and shared. Forall wikib x, forall wikib y,
x called on y is a wikib, which may be halted or evaling (to a halted wikib
or never halts). Every wikib is a derivative-work of leaf, which can be
proven by calling leaf on itself in various combinations, to make any wikib.
While obeying this license and using a wikibinator203 VM that correctly
implements the spec, it is safe to call any wikib on any wikib since all
it does is find or create wikibs, but if its used to control external
systems (such as robots, buying and selling things, or telling people
what to believe or what to do outside a simulated world, or copying a
wikib to a new file, renaming that file x.exe, then double-clicking that
file), it is entirely the responsibility of who hooks it to those systems
to verify its safe, such as by math proofs, networks of digital signatures,
or other evidence, especially considering that it can create all possible
computer viruses and ransomware and other evil things (safely in a
sandbox across 1 or many computers) and good things, and that in 1 of
its 2 namespaces (evilbit=true), it is an antivirus quarantine and
uncensored area, a sandbox across whichever computers opt into using
this data structure together, where all possible wikibs are allowed.
In the antivirus quarantine, you may share viruses like posts in a
social network, turing-complete messages that others may, for example,
say ["this is a virus" TheVirus] or use the virus in a meme-like piece
of art (such as a satirical work making fun of viruses could literally
contain such viruses) and do experiments, make games, musical
instruments, tools, or anything of pure information. It would be very
destructive to the system if there is any possible math statement which
is not allowed, such as removing a virus or other "evil" wikibs while
it has incoming pointers. It would be destructive to the wikib systems,
because halting-oracles have been proven impossible, and a halting-oracle
would be needed to determine if a certain wikib would generate, or would
not generate, a certain other wikib, without waiting up to an infinite
time to observe what it does (by the universal lambda math). The other
namespace (evilbit=false) works like the normal internet, if those who
opt in can find a way to do that without breaking the wikib math so much
its unusable, a way to claim a certain wikib is safe, unlike in
evilbit=true where there is no reasonable expectation that it is safe
to give those wikibs execute permission, or to believe any information
in them, or to obey anything they might tell you to do with a message
on the screen. It would be negligence for someone to give execute
permission to, believe, or obey, anything in an antivirus quarantine
(which many apps may run inside across many computers) if that causes
a problem, and similarly for the evilbit=false area, since saying its
evilbit=true or evilbit=false (which happens in the first byte of a
256 bit id for example) is just a word that people or computers can
say about a wikib, that they believe it to be safe or not.
If in doubt, use evilbit=true aka antivirus quarantine.
The 256 (or 512) bit ids can safely be shared in public as #hashtags.
The sending and receiving of this data structure across a network
does not count that network as an "external system"
and is part of the sandbox. Similarly, a Human just using the
facts of math together with other Humans and AIs, is part of the sandbox,
as a wikib can exist inside a Human mind (which is turing-complete),
but believing or obeying it in the Human mind is outside the sandbox.
A wikib being a "fact of math" is inside the sandbox,
and can derive its own ids which are similar to godel-numbers,
and in the pure deterministic (not "approximations") way of using it,
it can not lie about anything inside the sandbox,
but if its viewed as statements about outside the sandbox those can be lies.
For example, the wikib "this sentence is false", and "two plus two equals five",
are both true, since those are just utf8 bytes, and it is true that
they do not break any rules of the universal lambda,
but if you view them as statements about natural-language
then that refers to patterns of thoughts outside the sandbox.
If instead you derive numbers and use the Ax opcode to prove
a function called on a param gives a certain return value,
then it will not halt if you try to eval either of those in pure math form.
All halted wikibs are true. All wikibs which will never halt are false.
Approximations of wikibs can guarantee halting by recursively limiting
compute time and memory etc, so in theory there should be some way
to safely use it to operate time critical dangerous processes
in the evilbit=true area, but due to the evilbit=false area
"throwing a wrench into the machine" by removing pieces of math
based on Human opinions etc, the antivirus quarantine is safest.
The antivirus quarantine, in the way its the math that the code is based on,
has already whitelisted an infinite set,
(of all of a certain kind of universal function, by calling it on itself in various combos)
unlike the common practice of blacklisting "evil" things as they are
observed or predicted over time. The only thing the antivirus quarantine blacklists
is mutable state. A pure function can not infect a harddrive or RAM etc,
since it can not call thePureFunction(mutableState)->next_mutableState,
except to store cached function calls (including wrapping tiny and bigdata size bitstrings).
A virus is only dangerous if it can modify some mutable state.
This is a formal-verification system. This is also a low-latency number-crunching turing-complete system.
For example, this system's turing-complete-type-system can have a linked-list of lambdas
that when called on [church-pair of themself and themself] evals to one of the representations of the exact value of pi,
and if you tried to insert into that linked-list a value not matching that, it would never halt,
and if you tried to insert, in parallel a million values matching that,
you would in each of those million wikib_called_on_wikib get a linked-list with 1 more thing in it.
<br><br>
If there is any conflict between the above "Nobody owns wikibs" paragraph and the below 2 paragraphs copied from MIT license,
then that "Nobody owns wikibs" paragraph wins, overpowers the legal effects, of the 2 paragraphs below,
and if that is not legally possible to do then it is not legally possible to use this software at all.
<br><br>
Except for the "Nobody owns wikibs" paragraph above, which in a copyleft way applies to every wikibinator203 VM,
permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<br><br>
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
]]]

</body></html>
