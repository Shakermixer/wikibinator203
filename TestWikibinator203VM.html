<!DOCTYPE html><html><head>
<script src=Wikibinator203VM.js></script>
<script>

let U = Wikibinator203; //the universal function

let vm = Wikibinator203().vm;

var dom = id=>document.getElementById(id);

var h = '';

h += 'Wikibinator203='+Wikibinator203+' Push F12 to see some tests in browser console.';
h += '\n\n<br><br>In the ops list below, from vm.opInfo, you can use op name, such as S, T, Pair, (F U) is identityFunc, etc. Some ops arent working yet. More ops will be filled in later. This is early into the wikibinator203 prototype. Try it in the textareas. When you change text in the top textarea, it evals and puts the output into the bottom textarea, which you should be able to copy into the top textarea and edit more. This will be easier once these low level basics are worked out and you can do everything (TODO) by drag and drop across the internet with your friends in realtime.';
for(let op of vm.opInfo){
	 h += '\n\n<br><br>'+JSON.stringify(op);
}

window.onload = ()=>{
	dom('mainDiv').innerHTML = h;
	
	//let firstCode = '(S (F U) (F U) Pair)';
	//let firstCode = '[(CallParamOnItself#(S I#(F U) I) Pair) (CallParamOnItself F)]';
	let firstCode = '[(CallParamOnItself#(S I#(F U) I) Pair) (CallParamOnItself F) CallParamOnItself]';
	dom('codeIn').value = firstCode;
	evalTextAreas();
};

var evalTextAreas = ()=>{
	vm.refill();
	let textOut = 'ERROR';
	try{
		let wikibinator203CodeIn = dom('codeIn').value;
		if(dom('isEvalElseOnlyParse').checked){
			console.log('Eval');
			let fnOut = Eval(wikibinator203CodeIn);
			textOut = ''+fnOut;
		}else{
			console.log('Parse');
			let parseTree = Parse(wikibinator203CodeIn)
			textOut = ''+parseTree;
		}
	}catch(e){
		textOut = 'ERROR: '+e;
	}
	dom('codeOut').value = textOut;
};


var Eval = vm.eval; //of wikibinator203 code string -> fn. fn means a wikibinator203 lambda that is a javascript function of 1 param.

var lastParseTree = null;

var Parse = code=>(lastParseTree=vm.parse(code));

/*//TODO move this to a separate js file or the html file...

console.log('Script (near) ending. Wikibinator203 = '+Wikibinator203);
for(let i=0; i<8; i++) console.log('');

var U = Wikibinator203;


var vm = U().vm;


console.log('Wikibinator203...');

console.log('Wikibinator203 = '+Wikibinator203);

var UU = U(U);

console.log('UU = '+UU);


var ops = U().vm.ops;
for(name in ops){ console.log('Creating var: '+name); eval(name+' = ops.'+name); };

console.log('T().o8() == '+T().o8());
T(UU)(U);

console.log('\n\n\n\n\nS(S(T)(T))(T)  aka {T T T} = '+S(S(T)(T))(T)+'\n\n\n\n\n');

console.log('\n\n\n\n\nS(S(T)(S(L)(R)))(T) aka {T {L R} T} = '+S(S(T)(S(L)(R)))(T)+'\n\n\n\n\n');

console.log('\n\n\n\n\nT(T(Seq(S(S(T)(Pair))(T)))) = '+T(T(Seq(S(S(T)(Pair))(T))))+'\n\n\n\n\n');

console.log('\n\n\n\n\nPair(Pair(S)(S))(R) = '+Pair(Pair(S)(S))(R)+'\n\n\n\n\n');

console.log('\n\n\n\n\nInfcur(U)(U)(Infcur(T)) = '+Infcur(U)(U)(Infcur(T))+'\n\n\n\n\n');

console.log('\n\n\n\n\nSeq(Infcur(L)(R)(Seq(T(Seq(Pair))))) aka _[L R _,_Pair] = '+Seq(Infcur(L)(R)(Seq(T(Seq(Pair)))))+'\n\n\n\n\n');

console.log('starting basic tests of vm.eval:');

let wikibinator203Code = '_[L R _,_Pair]';
let evaledTo = vm.eval(wikibinator203Code);
if(evaledTo != Seq(Infcur(L)(R)(Seq(T(Seq(Pair)))))) throw 'Eval failed';

wikibinator203Code = '{T {L R} T}';
evaledTo = vm.eval(wikibinator203Code);
if(evaledTo != S(S(T)(S(L)(R)))(T)) throw 'Eval failed';

console.log('vm.eval passed basic tests.');
*/
	
</script>
</head><body>
<h1>TODO TDD for Names# etc, but get the basics of parsing, eval, (Lambda [x y z] ...) MutLam, etc, working first.<br>
TODO I want ability to run most things in pure determinism mode (the cleanest). define all the primitive (especially double and int, maybe float, maybe byte, etc) ops, that both JVM and browser javascript (and maybe few other systems if can find overlapping bit behaviors) do deterministicly exactly the same as eachother, and use that as the deterministic definitions of the ops double*double double+double sine(double) etc. There must be an implementation of them made of U/TheUniversalLambda that doesnt depend on calling * + sine etc, Evaler optimized to use those if they exactly match. Careful to use final/const keyword(s) for order of ops and to prevent merging ops. Unlikely to match alot of them in GPU.js, but in lazycl it seems able to match what JVM does, for example. Some things will just have to be done in allownondeterministicroundoff (what was it called?) mode (a vm.mask_*) if want it fast enough such as teraflop graphics of 3d fractals etc. Also, for determinism, can only loop over Mut keys (as in MutLam etc), if sorted, but wrapper of Float64Array etc in Mut is int keys so thats not relevant there.<br>
TODO maybe an op for avl tree, or 2-way-trie, of 256 bit keys (generated by any fn as idMaker) and fn vals? Cuz need ability to map fn to fn, such as for Names# in a self-hosting code editor and will need it for a variety of things. Could derive it, and make an Evaler, but having an op for a basic kind of it might be good too. See addOp.<br>
TODO string literals when first letter is lowercase<br>
TODO cbt, partialDedup, and typeval<br>
TODO basic math ops including + * / sine of doubles and ints etc<br>
TODO Names#, just keep it in Node.localName andOr vm.Viewer vm.View etc, no lambda treemaps yet.<br>
TODO Names## syntax for commented func of 1 param, that op.<br>
TODO (Lambda [a b c] ...)<br>
TODO MutLam and compiling to js code<br>
TODO simple exeriments with voxel32<br>
TODO compiling to GPU.js code<br>
TODO tree of voxel32 with voxel32 offset per branch and cbt of n voxel32 per branch<br>
TODO webaudioapi, using MutLam to generate sound samples and read incoming microphone electric guitar etc<br>
TODO...<br>
</h1>
TODO at runtime when VM boots, and again after other libs may have been loaded after it, verify js String and Number etc dont have any of the fields im adding to Mut such as .d for doublearray and .m for map of string (generated by Mut.toString to be a globalid256 (which may be a literal string that fits in id, abbreved if its smaller)) to Mut_or_double, etc, for security since some lib might be designed so that when wikibinator203 and that lib are loaded at once, that wikibinator203's generated code would mistake (2+3).m for that, for example, which might break the VM andOr let it run any js code it wants in the browser instead of just code generated by the wikibinator203 VM.<br>
<br>
	<center>
		<h2>Test Wikibinator203 prototype (incomplete but works a little)</h2>
		Wikibinator203 code in. It evals while you type,<br> but until vm.stackTime and vm.stackMem are working,<br> you might have to close and reopen browser tab if you write an infinite loop).
		Example: (Pair (F U) S F) -> S<br>
		Example: (Pair (F U) S T) -> (F U)<br>
		Example: Pair -> Pair<br>
		Example: ([L R L R] Pair Pair L S R) -> [L R L R Pair Pair L S R]<br>
		Example: (L ([L R L R] Pair Pair L S R)) -> [L R L R Pair Pair L S]<br>
		Example: (R ([L R L R] Pair Pair L S R)) -> R<br>
		Example: (L U (R U)) -> U<br>
		Example: (L L (R L)) -> L<br>
		Example: (L R (R R)) -> R<br>
		Example: (L S (R S)) -> S<br>
		Example: (L (Pair S T) (R (Pair S T))) -> (Pair S T) - aka (Pair S T) is the iota lambda<br>
		Example: ((Pair S T) (Pair S T) [L R L R S]) -> [L R L R S] - cuz iota called on itself is an identityFunc.<br>
		Example: ((Pair S T) (Pair S T) (Pair S T)) -> (Pair S T) - cuz iota called on itself is an identityFunc.<br>
		Example: ((Pair S T) ((Pair S T) ((Pair S T) (Pair S T)))) -> T<br> - as in <a href=https://en.wikipedia.org/wiki/Iota_and_Jot>https://en.wikipedia.org/wiki/Iota_and_Jot</a> cuz T is the K of SKI-Calculus.<br>
		Example: ((Pair S T) ((Pair S T) ((Pair S T) ((Pair S T) (Pair S T))))) -> S<br> - as in <a href=https://en.wikipedia.org/wiki/Iota_and_Jot>https://en.wikipedia.org/wiki/Iota_and_Jot</a> cuz T is the K of SKI-Calculus.<br>
		This is an infinite loop (though runs out of javascript stack: (S (F U) (F U) (S (F U) (F U)))<br>
		[(CallParamOnItself#(S I#(F U) I) Pair) (CallParamOnItself F)] -> [(Pair Pair) (F F)] //TODO keep the Names#.<br>
		<b>It will be much easier use when Names#(...) and drag-and-drop and 1024x1024 per pixel graphics are working.</b><br>
		<br>
		Wikibinator203 code in.<br>
		<textarea id=codeIn rows="5" cols="100" oninput="evalTextAreas();"></textarea><br>
		Eval of the above code, out:<br>
		<textarea id=codeOut rows="5" cols="100" readonly></textarea><br>
		<input type=checkbox id=isEvalElseOnlyParse checked oninput="evalTextAreas();"></input><label for=isEvalElseOnlyParse>eval (else parse only)</label><br>
	</center>
	
	<a href=https://github.com/benrayfield/wikibinator203>https://github.com/benrayfield/wikibinator203</a><br>
	<a href=https://twitter.com/wikibinator>https://twitter.com/wikibinator</a><br>
	<br>
	
	<div id="mainDiv"></div>
</body></html>
