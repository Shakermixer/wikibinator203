<!DOCTYPE html><html><head>
<meta charset="UTF-8">
<script src="Wikibinator203VM.js" charset="UTF-8"></script>
<script>
//https://raw.githubusercontent.com/benrayfield/jsutils/master/src/sha256.js

var sha256 = function(bytesIn){
	//var t = typeof bytesIn;
	//if(t != 'Uint8Array') throw 'Expected Uint8Array but got a '+t; //this check wont work because its like a map of index to byte
	
	var chunks = Math.floor((bytesIn.byteLength+9+63)/64); //512 bit each
	
	//Copy bytesIn[] into b[], then pad bit1, then pad bit0s,
	//then append int64 bit length, finishing the last block of 512 bits.
	//byte b[] = new byte[chunks*64];
	var b = new Uint8Array(chunks*64);
	
	//System.arraycopy(bytesIn, 0, b, 0, bytesIn.byteLength);
	b.set(bytesIn, 0);
	
	b[bytesIn.byteLength] = 0x80;
	
	//long bitLenTemp = bytesIn.byteLength*8;
	var bitLenTemp = bytesIn.byteLength*8; //in js, this has float64 precision, which is more than enough for Uint8Array size
	for(var i=7; i>=0; i--){
		b[b.byteLength-8+i] = bitLenTemp&0xff;
		bitLenTemp >>>= 8;
	}
	
	//log('b as hex = '+bitfuncs.uint8ArrayToHex(b));
	
	
	var a = new Uint32Array(136);
	//"first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311"
	a[0]=0x428a2f98;
	a[1]=0x71374491;
	a[2]=0xb5c0fbcf;
	a[3]=0xe9b5dba5;
	a[4]=0x3956c25b;
	a[5]=0x59f111f1;
	a[6]=0x923f82a4;
	a[7]=0xab1c5ed5;
	a[8]=0xd807aa98;
	a[9]=0x12835b01;
	a[10]=0x243185be;
	a[11]=0x550c7dc3;
	a[12]=0x72be5d74;
	a[13]=0x80deb1fe;
	a[14]=0x9bdc06a7;
	a[15]=0xc19bf174;
	a[16]=0xe49b69c1;
	a[17]=0xefbe4786;
	a[18]=0x0fc19dc6;
	a[19]=0x240ca1cc;
	a[20]=0x2de92c6f;
	a[21]=0x4a7484aa;
	a[22]=0x5cb0a9dc;
	a[23]=0x76f988da;
	a[24]=0x983e5152;
	a[25]=0xa831c66d;
	a[26]=0xb00327c8;
	a[27]=0xbf597fc7;
	a[28]=0xc6e00bf3;
	a[29]=0xd5a79147;
	a[30]=0x06ca6351;
	a[31]=0x14292967;
	a[32]=0x27b70a85;
	a[33]=0x2e1b2138;
	a[34]=0x4d2c6dfc;
	a[35]=0x53380d13;
	a[36]=0x650a7354;
	a[37]=0x766a0abb;
	a[38]=0x81c2c92e;
	a[39]=0x92722c85;
	a[40]=0xa2bfe8a1;
	a[41]=0xa81a664b;
	a[42]=0xc24b8b70;
	a[43]=0xc76c51a3;
	a[44]=0xd192e819;
	a[45]=0xd6990624;
	a[46]=0xf40e3585;
	a[47]=0x106aa070;
	a[48]=0x19a4c116;
	a[49]=0x1e376c08;
	a[50]=0x2748774c;
	a[51]=0x34b0bcb5;
	a[52]=0x391c0cb3;
	a[53]=0x4ed8aa4a;
	a[54]=0x5b9cca4f;
	a[55]=0x682e6ff3;
	a[56]=0x748f82ee;
	a[57]=0x78a5636f;
	a[58]=0x84c87814;
	a[59]=0x8cc70208;
	a[60]=0x90befffa;
	a[61]=0xa4506ceb;
	a[62]=0xbef9a3f7;
	a[63]=0xc67178f2;
	//h0-h7 "first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19"
	a[64]=0x6a09e667;
	a[65]=0xbb67ae85;
	a[66]=0x3c6ef372;
	a[67]=0xa54ff53a;
	a[68]=0x510e527f;
	a[69]=0x9b05688c;
	a[70]=0x1f83d9ab;
	a[71]=0x5be0cd19;
	//a[72..135] are the size 64 w array of ints
	for(var chunk=0; chunk<chunks; chunk++){
		var bOffset = chunk<<6;
		//copy chunk into first 16 words w[0..15] of the message schedule array
		for(var i=0; i<16; i++){
			//Get 4 bytes from b[]
			var o = bOffset+(i<<2);
			a[72+i] = ((b[o]&0xff)<<24) | ((b[o+1]&0xff)<<16) | ((b[o+2]&0xff)<<8) | (b[o+3]&0xff);
		}
		//Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
		for(var i=16; i<64; i++){
			//s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)
			//s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10)
			//w[i] := w[i-16] + s0 + w[i-7] + s1
			var wim15 = a[72+i-15];
			var s0 = ((wim15>>>7)|(wim15<<25)) ^ ((wim15>>>18)|(wim15<<14)) ^ (wim15>>>3);
			var wim2 = a[72+i-2];
			var s1 = ((wim2>>>17)|(wim2<<15)) ^ ((wim2>>>19)|(wim2<<13)) ^ (wim2>>>10);
			a[72+i] = a[72+i-16] + s0 + a[72+i-7] + s1;
		}
		var A = a[64];
		var B = a[65];
		var C = a[66];
		var D = a[67];
		var E = a[68];
		var F = a[69];
		var G = a[70];
		var H = a[71];
		for(var i=0; i<64; i++){
			/* S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
			ch := (e and f) xor ((not e) and g)
			temp1 := h + S1 + ch + k[i] + w[i]
			S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
			maj := (a and b) xor (a and c) xor (b and c)
			temp2 := S0 + maj
			h := g
			g := f
			f := e
			e := d + temp1
			d := c
			c := b
			b := a
			a := temp1 + temp2
			*/
			var s1 = ((E>>>6)|(E<<26)) ^ ((E>>>11)|(E<<21)) ^ ((E>>>25)|(E<<7));
			var ch = (E&F) ^ ((~E)&G);
			var temp1 = H + s1 + ch + a[i] + a[72+i];
			var s0 = ((A>>>2)|(A<<30)) ^ ((A>>>13)|(A<<19)) ^ ((A>>>22)|(A<<10));
			var maj = (A&B) ^ (A&C) ^ (B&C);
			var temp2 = s0 + maj;
			H = G;
			G = F;
			F = E;
			E = D + temp1;
			D = C;
			C = B;
			B = A;
			A = temp1 + temp2;
		}
		a[64] += A;
		a[65] += B;
		a[66] += C;
		a[67] += D;
		a[68] += E;
		a[69] += F;
		a[70] += G;
		a[71] += H;
	}
	//RETURN h0..h7 = a[64..71]
	//byte ret[] = new byte[32];
	var ret = new Uint8Array(32);
	for(var i=0; i<8; i++){
		var ah = a[64+i];
		ret[i*4] = (ah>>>24)&0xff;
		ret[i*4+1] = (ah>>>16)&0xff;
		ret[i*4+2] = (ah>>>8)&0xff;
		ret[i*4+3] = ah&0xff;
	}
	return ret;
};
</script>
<script>
//https://github.com/benrayfield/jsutils/blob/master/src/unicode.js

var unicode = {
	//TODO consider using TextEncoder instead, which is a web standard in progress and works in at least firefox chrome and 1 other
	
	utf8TextEncoder: new TextEncoder('utf-8'),
	
	utf8TextDecoder: new TextDecoder('utf-8'),
	
	stringToUtf8AsUint8Array: function(s){
		//log('unicode.utf8TextEncoder='+unicode.utf8TextEncoder+' '+mapToString(unicode.utf8TextEncoder));
		//log('param of encode: '+s);
		var u = unicode.utf8TextEncoder.encode(s);
		//var t = typeof u;
		//if(t != 'Uint8Array') throw 'Expected TextEncoder.encode(string) to return Uint8Array but got a '+t+': '+u+': '+mapToString(u);
		return u;
	},
	
	utf8AsUint8ArrayToString: function(bytes){
		return unicode.utf8TextDecoder.decode(bytes);
	},
	
	asBytes: function(stringOrBytes){
		var t = typeof stringOrBytes;
		if(t == 'Uint8Array') return stringOrBytes;
		if(t == 'string') return unicode.stringToUtf8AsUint8Array(stringOrBytes);
		throw 'Unknown type: '+t;
	},
	
	asString: function(stringOrBytes){
		var t = typeof stringOrBytes;
		if(t == 'string') return stringOrBytes;
		if(t == 'Uint8Array') return unicode.utf8AsUint8ArrayToString(stringOrBytes);
		throw 'Unknown type: '+t;
	}
	
};
</script>
<script>
//TODO move window out of that lambda then... const Wikibinator203DragAndDropTreeUI = (()=>{

//This script is under the Wikibinator203 license.

//drag and drop tree UI for viewing and calling Wikibinator203 fns/lambdas...

'use strict';

const U = Wikibinator203; //the universal function
if(U(U(U))(U) !== U(U(U))(U)) throw 'Lambda equality is broken';
const vm = Wikibinator203.n.vm; //anyWikibinator203Lambda.n is its vm.Node instance, wrapped in a lambda by vm.lambdize(node)

const loadOpsByName = true;
console.log('loadOpsByName='+loadOpsByName);

//let S = vm.ops.S;
//let T = vm.ops.T;
//let F = vm.ops.F;
//let Pair = vm.ops.Pair;
if(!vm) throw 'No vm';
if(loadOpsByName) for(let op in vm.ops){
	if(window[op]) throw 'Already have var window.'+op;
	window[op] = vm.ops[op];
	console.log('Created var for opcode as lambda: window.'+op);
}

//sha256hex of text. TODO optimize by using a normal hashtable to dedup Splits
var hashText = text=>vm.bytesToHex(sha256(unicode.stringToUtf8AsUint8Array(text)));

var randInt = n=>Math.floor(Math.random()*n);

var between = (min, val, max)=>Math.max(min, Math.min(val, max));

var betweenInt = (min, val, max)=>Math.floor(Math.max(min, Math.min(val, max)));

var asByte = num=>betweenInt(0,num,255);

var colorStr = function(redFraction, greenFraction, blueFraction){
	let r = asByte(redFraction*256);
	let g = asByte(greenFraction*256);
	let b = asByte(blueFraction*256);
	let s = '000000'+(r*65536+g*256+b).toString(16);
	return '#'+s.substring(s.length-6);
};

//var randColorStr = ()=>colorStr(.45+.55*Math.random(), .45+.55*Math.random(), .45+.55*Math.random());

var randColorStr = ()=>colorStr(randRed(), randGreen(), randBlue());

/*const firstCode =
`{
	(T Sqrt)
	{
		(T +)
		{(T Sqr#{(T *) I#(F U) I}) (P x)}
		{(T Sqr) (P y)}
	}
}`;*/

const firstCode =
`[((Pair [L R]) [[[[
I#(F U)
Sqr#{(T *) I I}
Hypot#(
	λ [x y]
	[this is [a comment] with a function Sqr in it]
	{
		(T Sqrt)
		{
			(T +)
			{(T Sqr) (P x)}
			{(T Sqr) (P y)}
		}
	}
)
[the hypotenuse of [a right triangle of sides 6 and 8] is (Hypot 6 8) and [that func is Hypot] and [as a 1 param func is (Hypot 6)]]
{[hello world] {abc def ghi}}
(Pair L R)
(T (Pair (T L) R))
2.34
]]]])]`;


/*const firstCode =
`[
I#(F U)
Sqr#{(T *) I I}
Hypot#(
	λ [x y]
	[this is [a comment] with a function Sqr in it]
	{
		(T Sqrt)
		{
			(T +)
			{(T Sqr) (P x)}
			{(T Sqr) (P y)}
		}
	}
)
the hypotenuse of a right triangle of sides 6 and 8 is (Hypot 6 8) and that func is Hypot and as a 1 param func is (Hypot 6)
{[hello world] {abc def ghi}}
(Pair L R)
(T (Pair (T L) R))
2.34
]`;
*/

//TODO 0xf922 aka cbt literal

//const firstCode = '[I#(F U) Sqr#{(T *) I I}]';

const exampleFnToDisplay = vm.eval(firstCode); //a Wikibinator203 fn/lambda (which is a js lambda)


//START Splat.dobs keys:

/*
//The dom object that the other splat dobs are childs of. This is normally a div.
const SELF = 'self';

//Example: Display '[' or '(' at top left corner.
//This might just be a html label.
const PREFIX = 'prefix';

//drop (or during drag displays where would drop) left/above/before the left of 2 childs, then forkEdit
//rootSplit by some interpretation of what dropping it there means, considering it uses a high level syntax.
//This is normally a div, size 0 and hidden until needed.
const DROPLEFT = 'dropleft';

//left splat child of a splat.
//This is normally a div.
const LEFT = 'left';

//drop (or during drag displays where would drop) between 2 childs, then forkEdit
//rootSplit by some interpretation of what dropping it there means, considering it uses a high level syntax.
//This is normally a div, size 0 and hidden until needed.
const DROPMID = 'dropmid';

//where to display a canvas, text, pdf file, jpg file, or other literal value, but only do this if childs are NOT displayed
//(a necessary but not sufficient condition),
//check split for should it be displayed and caching of the Uint8Array of canvas bytes etc.
//This is normally a div or maybe a canvas, or a div with a canvas in it, etc.
const LITERAL = 'literal';

//right splat child of a splat.
//This is normally a div.
const RIGHT = 'right';

//drop (or during drag displays where would drop) right/below/after the right of 2 childs, then forkEdit
//rootSplit by some interpretation of what dropping it there means, considering it uses a high level syntax.
//This is normally a div, size 0 and hidden until needed.
const DROPRIGHT = 'dropright';

//Example: Display ']#NameXYZ' or ')#NameXYZ' or ']' or ')' at bottom left corner or on right if 1 line.
//This might just be a html label.
const SUFFIX = 'suffix';
*/

//END Splat.dobs keys.


//TODO "SOLUTION: Fixing this by dividing Split into 2 classes: Split (immutable, up from any closed leafs),
//and Splat (mutable, has dom nodes). Split.prototype.displayIn(Splat) fills in those dom nodes,
//and removes some dom nodes if they're no longer used.
//Split can share branches and is a forest (like fn). Split might be made of fns later (TODO?).
//Splat is a tree and cant share branches.
//A split is dragged from any part of Splat to any part of Splat."
//
//var Splat = function(parentSplatOrNull, splate){
//
//OLD: isRight means is right child, else left child, of parentSplatOrNull, or if !parentSplatOrNull then this is a root, not a child.
//
//selfDob is normally parentSplatOrNull.dobs.left or parentSplatOrNull.dobs.right or if !parentSplatOrNull then its probably rootDob or dragDob.
var Splat = function(parentSplatOrNull, selfDob){

	//this.splate = splate; //doesnt include splates for leftSplat or rightSplat. Its local to this Splat.
	//this.splate = defaultSplate; //so Splat.setSplit can display it first. Has no childs.
	//this.split = null; //TODO
	this.split = defaultSplit;
	
	
	
	/*
	if(this.splate.isOpen && this.splate.isDisplayName){
		fnMeta(this.splate.fn).numOpenNamedSplats++;
		//FIXME do fnMeta(this.splate.fn).numOpenNamedSplats--
		//when this.splate is replaced with a !isOpen and !isDisplayName or this Splat removed.
	}*/
	
	//map of string to dob (dom object).
	//TODO dobs for the 2 childs, prefix and suffix, etc.
	//TODO also include dobs for "include extra divs, normally empty, in every Splat, in every
	//possible place in that splat it could be dropped, including hidden splats".
	this.dobs = {
		self: selfDob,
	};
	
	const ThisSplat = this;
	selfDob.addEventListener(
		'click',
		function(event){
			//console.log('click '+ThisSplat);
			event.stopPropagation();
			//requestAnimationFrame(function(){
				//console.log('ThisSplat_isRoot='+(ThisSplat===rootSplat));
				setSelSplat(ThisSplat);
			//});
			//event.stopPropagation();
		}
	);
	
	this.parentSplat = parentSplatOrNull || null; //null if this is a top Splat (probably just these 2: rootSplat and dragSplat)
	this.leftSplat = null; //null if not viewing left child
	this.rightSplat = null; //null if not viewing right child
	
	this.createDobsIfNotExist(); //other than selfDob which is given

};

//lazy create left splat with defaultSplate (waiting for setSplate to cause display of nontrivial contents)
Splat.prototype.L = function(){
	if(!this.leftSplat){
		//let leftSplate = defaultSplate.copy(); //FIXME shouldnt need to copy, cuz should use as immutable. Also, this shouldnt be defaultSplate.
		//let leftSplate = this.splate.simpleLeftSplate();
		//this.leftSplat = new Splat(this, leftSplate);
		//this.leftSplat = new Splat(this, leftSplate);
		if(!this.dobs.left) throw 'No left dob';
		this.leftSplat = new Splat(this, Pob('div',this.dobs.left)); //so no dobs are shared between parent.dobs and child.dobs
		this.leftSplat.parentSplat = this;
	}
	return this.leftSplat;
};

//lazy create right splat with defaultSplate (waiting for setSplate to cause display of nontrivial contents)
Splat.prototype.R = function(){
	if(!this.rightSplat){
		//let rightSplate = defaultSplate.copy(); //FIXME shouldnt need to copy, cuz should use as immutable. Also, this shouldnt be defaultSplate.
		//let rightSplate = this.splate.simpleRightSplate();
		if(!this.dobs.right) throw 'No right dob';
		this.rightSplat = new Splat(this, Pob('div',this.dobs.right)); //so no dobs are shared between parent.dobs and child.dobs
		this.rightSplat.parentSplat = this;
	}
	return this.rightSplat;
};

//get or set attribute of dob. If dont give a value, just reads it. If give value, writes it then returns same dob. Use null to remove attribute.
var attr = (dob,attrName,optionalAttrVal)=>{
	if(optionalAttrVal === undefined){ //read attr
		return dob.getAttribute(attrName);
	}else{ //write attr
		if(optionalAttrVal === null){
			dob.removeAttribute(attrName);
		}else{
			dob.setAttribute(attrName, optionalAttrVal);
		}
		return dob;
	}
};

//new dob/domObject
var Nob = (tag,optionalParent,optionalInnerHtml)=>{
	let dob = document.createElement(tag);
	if(optionalInnerHtml) dob.innerHTML = optionalInnerHtml;
	if(optionalParent) optionalParent.appendChild(dob);
	return dob;
};

//unPadded New dOB/domObject
var Pob = (tag, optionalParent, optionalInnerHtml)=>{
	//unpad(Nob(tag,optionalParent,optionalInnerHtml));
	let dob = document.createElement(tag);
	unpad(dob);
	if(optionalInnerHtml) dob.innerHTML = optionalInnerHtml;
	if(optionalParent) optionalParent.appendChild(dob);
	return dob;
};

Splat.prototype.parentDob = function(){
	if(this.parentSplat){
		if(!this.parentSplat.dobs.self){
			console.log('child splat creating dobs in parent. FIXME? why didnt parent do it already?');
			this.parentSplat.createDobsIfNotExist();
		}
		return this.parentSplat.dobs.self;
	}else{
		if(!rootDob) throw 'No rootDob';
		return rootDob;
	}
};

//Keys in splat.dobs, except 'self' which contains all those.
//var childDobNames = 'controls prefix dropleft left dropmid literal right dropright suffix'.split(' ');
var childDobNames = 'prefix dropleft left dropmid literal right dropright suffix'.split(' ');

var sytyToPushChar_ = {
	IC0: '[',
	'IC+': '[',
	C: '(',
	S0: '(',
	S1: '(',
	S2: '{',
	//T1: ',',
	T1: 'T', //Change ',' to 'T' 
};

var sytyToPushChar = syty=>(sytyToPushChar_[syty] || 'FIXME_WHAT_PUSH_CHAR_FOR_SYTY='+syty);

var sytyToPopChar_ = {
	IC0: ']',
	'IC+': ']',
	C: ')',
	S0: ')',
	S1: ')',
	S2: '}',
	T1: '',
};

//check !==undefined cuz pop char for T1 is '' aka empty string cuz its just ',' (its push char) on the left.
var sytyToPopChar = syty=>(sytyToPopChar_[syty]!==undefined ? sytyToPopChar_[syty] : 'FIXME_WHAT_POP_CHAR_FOR_SYTY='+syty);

/*
Splat.prototype.updateSelfDivStyle = function(){
	let sty = this.dobs.self.style;
	sty.borderStyle = 'outset';
	let red = .45+.55*Math.random();
	let green = .45+.55*Math.random();
	let blue = .45+.55*Math.random();
	let brightMul = .85;
	if(this.isSelected()){
		console.log('isSelected splat='+this);
		red = green = blue = 1;
	}
	sty.backgroundColor = colorStr(red*brightMul,green*brightMul,blue*brightMul);
	sty.borderWidth = '15px';
	sty.borderColor = colorStr(red,green,blue);
};*/

Splat.prototype.createDobsIfNotExist = function(){


	/*
	TODO make table have fewer rows/cols and put a flex layout in 1 of them to
	change between vertical and horizontal of: dropleft left dropmid mid dropright right.
	Leave prefix and suffix as they are in table.
	
	TABLE:
	[prefix]/ flex      \/ suffix2   \
	[suffix]\ colspan=2 /\ colspan=2 /
	
	This has to handle isOneLine being true or false, and empty dobs not taking space.
	
	Only need to handle these 4 cases with table/flexlayout/gridlayout/etc...
	
	prefix dropleft
	       left
	       dropmid
	       literal
	       right
	       dropright
	bigSuffixWithName
	
	prefix dropleft
	       left
	       dropmid
	       literal
	       right
	suffix dropright
	
	prefix dropleft left dropmid literal right dropright suffix
	
	prefix dropleft left dropmid literal right dropright bigSuffixWithName
	
	//dont do this one cuz #Name should always be on same line as suffix.
	//prefix dropleft
	//       left
	//       dropmid
	//       right
	//suffix dropright
	//#NameBIGBIGBIGBIG
	
	
	Maybe should get rid of dropleft dropmid and dropright and just put a separate drop icon with zIndex to display it above things.
	
	prefix left literal right suffix
	
	Literals will go in <...> such as canvas or text, other than #Names.
	
	*/






	if(!this.dobs.self){
		//this usually doesnt happen (if ever?). instead self is normally filled in by caller first.
		console.log('splat creating this.dobs.self, which contains the other dobs of this splat');
		this.dobs.self = Pob('div', this.parentDob());
	}
	/*for(let dobName of childDobNames){
		if(!this.dobs[dobName]){
			//let text = 'x_syty='+this.splate.syty;
			let text = null;
			let dob = Pob('div', this.dobs.self, text);
			dob.classList.add('wikib_'+dobName);
			this.dobs[dobName] = dob;
		}
	}*/
	//var childDobNames = 'controls prefix dropleft left dropmid literal right dropright suffix'.split(' ');
	//
	//prefix	left
	//
	//
	//suffix	right
	//and the others go around left and right etc, but might just need a 2x2 table.
	let d = this.dobs;
	if(!d.table){
		//d.controls = Pob('div', d.self);
		d.table = Pob('table',d.self);
		//attr(d.table,'border',5);
		attr(d.table,'border',options.borderWidth);
		d.rowa = Pob('tr', d.table);
		d.rowb = Pob('tr', d.table);
		d.rowc = Pob('tr', d.table);
		
		d.prefix = Pob('td', d.rowa); //upleft
		d.prefix.style.verticalAlign = 'top';
		d.uprightTd = Pob('td', d.rowa); //upright (up mid, if using upfarright)
		attr(d.uprightTd,'rowspan',2); //rowa and rowb. In upright theres flex layout thats either horizontal or vertical, and has both childs and 3 drop areas etc
		d.upright = Pob('div',d.uprightTd); //cuz rowspan of 2 is interfering with flex layout, making other table cells down left of it too low.
		d.upright.style.display = 'flex';
		//flex-direction: row row-reverse column colum-reverse
		d.upright.style['flex-direction'] = 'column'; //https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction
		//d.right2 = Pob('td', d.rowa); //if isOneLine, rowa is: prefix left right2 suffix2/upfarright
		//TODO rename upfarright to suffix2
		//d.upfarright = Pob('td', d.rowa); //upfarright, used if isOneLine, the suffix text goes here instead
		//d.upfarright.style.verticalAlign = 'top';
		
		d.suffixb = Pob('td', d.rowb); //left, mid height
		d.suffixb.style.verticalAlign = 'bottom';
		//d.downright = Pob('td', d.rowb); //downright (and colspan to go all the way to the right, under upright and under upfarright).
		//attr(d.downright,'colspan',2);
		//attr(d.downright,'colspan',3); //if isOneLine, rowa is: prefix left right2 suffix2. If not, its just prefix left and ignore the other 2
		
		d.suffixc = Pob('td', d.rowc); //whole rowc, on bottom. Used only if suffix is big, such as }#NameABC instead of }
		d.suffixc.style.verticalAlign = 'bottom';
		attr(d.suffixc,'colspan',2);
		
		
		d.dropleft = Pob('div', d.upright);
		d.left = Pob('div', d.upright);
		d.dropmid = Pob('div', d.upright);
		
		d.literal = Pob('div', d.upright);
		d.right = Pob('div', d.upright);
		d.dropright = Pob('div', d.upright);
		
		d.suffixfarright = Pob('div', d.upright);
		
		
		
		for(let dobName in d){
			d[dobName].classList.add('wikib_'+dobName);
		}
	}
	
};

var options = {};
//UPDATE: some of these are displayed in popup title when mouse hover, instead of where they say they're displayed.
options.displayWholeTostringAtEachRect = true;
//options.displayWholeTostringAtEachRect = false;
options.displaySplateDetailExceptFnAtEachRect = true;
//options.displaySplateDetailExceptFnAtEachRect = false;
//options.displayOnly_setSplit_inLiteral = true;
options.displayOnly_setSplit_inLiteral = false;
//options.display_isSelected_afterName = true;
options.display_isSelected_afterName = false;
options.displaySplatHeight = true;
//options.displaySplatHeight = false;

//a path of L R L L R...
options.displaySplatPathFromRoot = true;
//options.displaySplatPathFromRoot = false;

options.displayVarargLists = true;
//options.displayVarargLists = false;

options.displayVarargS = true; //sCurryList. use with isFoldL.
//options.displayVarargS = false; //sCurryList. use with isFoldL.

//options.displayDebugInfoAboutVarargS = true; //sCurryList. use with isFoldL.
options.displayDebugInfoAboutVarargS = false; //sCurryList. use with isFoldL.

options.displayVarargNormalCallPairs = true;
//options.displayVarargNormalCallPairs = false;


//foldT is like displayVarargS, displayVarargNormalCallPairs, and displayVarargLists, but its not vararg. It makes (T abc) appear as ,abc .
options.foldT = true;
//options.foldT = false;

//options.numlitPrefix = '&nbsp;NUMLIT:';
options.numlitPrefix = '';

//options.stringlitPrefix = '&nbsp;STRINGLIT:';
options.stringlitPrefix = '';

//options.namelitPrefix = '&nbsp;NAMELIT:';
options.namelitPrefix = '';

//options.cbtlitPrefix = '&nbsp;CBTLIT:0x';
options.cbtlitPrefix = '';

options.literalPrefix = '&nbsp;';

options.literalSuffix = '&nbsp;'; //add space cuz div didnt pad enough space on right side compared to the other 3 sides.

//affects splate.isOneLine. this is for testing.
//options.displayAllAsOneLine = true;
options.displayAllAsOneLine = false;

//overpowers options.displayAllAsOneLine. this is for testingt.
//options.displayAllAsOneLineRandomlyTrueOrFalsePerBranch = true;
options.displayAllAsOneLineRandomlyTrueOrFalsePerBranch = false;

//this is for testing.
//has no effect if options.displayAllAsOneLine since its an experiment in varying isOneLine per branch based on its width
options.do_forkTryMaxWidth_experimentOnWindowLoad = true;
//options.do_forkTryMaxWidth_experimentOnWindowLoad = false;

options.displayEstimateWidth = true;
//options.displayEstimateWidth = false;

options.estimatedFontWidth = 10; //pixels

/*
Splat.prototype.displayLocal = function(){
	console.log('Splat displayLocal this='+this);
	if(!this.dobs.self) throw 'No self dob';
	this.updateSelfDivStyle();
	let syty = this.splate.syty;
	if(this.splate.isDisplayPushAndPopChars){
		if(syty == 'U'){
			throw 'Dont look into the fractal (L U (R U))->U, isDisplayPushAndPopChars should be false and isDisplayName true and name should be U.';
		}
		let prefix = sytyToPushChar(syty);
		let suffix = sytyToPopChar(syty);
		//let prefix = syty=='U' ? '' : sytyToPushChar(syty);
		//let suffix = syty=='U' ? '' : sytyToPopChar(syty);
		//if(syty=='U' && !this.splate.isDisplayName){
		//	throw 'Must display name if its U
		//}
		if(this.splate.isDisplayName){
			//suffix += '#TODONAMEHERE';
			suffix += '#'+this.splate.name();
		}
		if(options.displayWholeTostringAtEachRect){
			suffix += '__'+this.splate.fn;
		}
		if(options.displaySplateDetailExceptFnAtEachRect){
			suffix += '__'+this.splate.toStringExceptFn();
		}
		suffix += '__isSelected='+this.isSelected();
		this.dobs.prefix.innerHTML = prefix;
		this.dobs.suffix.innerHTML = suffix;
	}else{
		if(syty == 'U'){
			if(!this.splate.isDisplayName){
				throw 'Must isDisplayName for leaf/U';
			}
		}
	}
};*/

Splat.prototype.toString = function(){
	return '[Splat splate='+this.splate()+' isSelected='+this.isSelected()+']';
};

/*
Splat.prototype.removeDobsExceptSelf = function(){
	for(let dobName in this.dobs){
		if(dobName !== 'self'){
			this.dobs[dobName].remove(); //remove from dom tree
			delete this.dobs[dobName];
		}
	}
};

Splat.prototype.removeDobs = function(){
	for(let dobName in this.dobs){
		this.dobs[dobName].remove(); //remove from dom tree
		delete this.dobs[dobName];
	}
};

Splat.prototype.displayIn = function(dob){
	if(!dob) throw 'No param dob';

	//TODO merge duplicate code between displayIn and displayLocal

	console.log('Splat displayIn '+dob);
	const ThisSplat = this;
	if(this.dobs.self != dob){
		console.log('Splat replacing its dobs');
		dob.innerHTML = '';
		dob.addEventListener(
			'click',
			function(event){
				//console.log('click '+ThisSplat);
				//requestAnimationFrame(function(){
					//console.log('ThisSplat_isRoot='+(ThisSplat===rootSplat));
					setSelSplat(ThisSplat);
				//});
				event.stopPropagation();
			}
		);
		this.removeDobs();
		this.dobs.self = dob;
		this.createDobsIfNotExist();
		this.displayLocal();
	}
	if(this.splate.isOpen){
		//if(this.leftSplat){
			console.log('Splat displaying left child');
			//this.leftSplat.displayIn(this.dobs.left);
			this.L().displayIn(this.dobs.left);
		//}
		//if(this.rightSplat){
			console.log('Splat displaying right child');
			//this.rightSplat.displayIn(this.dobs.right);
			this.R().displayIn(this.dobs.right);
		//}
	}
};
*/

Splat.prototype.isSelected = function(){
	return this.splate().isSelected;
	//return this===selSplat;
};




//a split is a view of a fn/lambda and its 2 child fn/lambdas, with each child being open or closed.
//a split is immutable. If its a view of U (leaf aka the universal combinator) or of a literal then childs wont be displayed.
//
//FIXME make it a fractal, not a tree.
//Making a drag-and-drop tree UI for #wikibinator. Each branch is a javascript lambda (useable on browser console
//or by drag and drop). But its not actually a tree. Its a fractal. Without exception, every branch has 2 child branches,
//that when called on eachother return the parent.
//
//The first n fns in a [] {} () <> can be viewed as closed, and just {} call that closed localId on those after the first n,
//but those would be different Splits.
/*
var Split = function(fn, leftOpen, rightOpen, literalOpen){
	this.fn = fn;
	//There can be multiple Splits for same fn since they can view it diff ways.
	this.leftSplit = null; //TODO a Split for L(this.fn)
	this.rightSplit = null; //TODO a Split for R(this.fn).
	this.leftOpen = leftOpen;
	this.rightOpen = rightOpen;
	this.literalOpen = literalOpen;
	
	//map of string to dob (dom object)
	this.dobs = {};
	
	FIXME should it be selfOpen instead of leftOpen and rightOpen?
	
	FIXME should Split know about height and width sizes recursively? Or leave that to Branch?
	
	TODO should Split have isOneLine var?
	
	TODO use vm.ParseTree to get syty (syntax type) of this.fn.
	
	TODO when start dragging with mouse, it should grab a Split, not a Branch?
};*/

console.log(`FIXME add all state thats in splat and selSplat etc, including:
	isSelected, and some form of color.
	Use splate as immutable, and add a Splat.setSpit(split) func that instantly updates dobs.
	and I want a splat editor.
	then make all parts of code appear.
	then fix the display so its like (	(	{	[.
	then add drag and drop.`);

//Splate is local SPLat and SPLit stATE (Split is immutable so has only 1) not including its childs.
//Renaming ViewType to Splate.
//
//(todo use as immutable) all the options for a splat and (if open) its 2 splat childs,
//including bit for is this splat open/closed, display as childs vs literal, css-like options, etc.
//A fn can be part of an immutable splate cuz (other than some internal optimizations)
//its an immutable (lazy-deduped, multi fn objects of same shape but different 128 bit localId) forest shape
//where all paths lead to U/Wikibinator203/TheUniversalCombinator.
//
//isFoldL is only true if isDisplayChilds. It displays only the right child and displays nothing or nearly nothing else, as if self is its own right child.
var Splate = function(fn, syty, isOpen, isOneLine, isLiteral, isDisplayName, isDisplayPushAndPopChars, isDisplayChilds, isFoldL, isUnary, showDropDobs, isSelected, red, green, blue){

	

	if(!vm.isLambda(fn)) throw 'Not a Wikibinator203 lambda: '+fn;
	this.fn = fn;

	if(!syty) throw 'No syty';
	//of what vm.ParseTree would compute syty of a fn. syty is a small string,
	//a syntax type (like in an AST node in parsing, but in the prototype VM thats vm.View)
	//This is instead of split.dity, but some values of dity (such as 'literal')
	//are not syty's so need more vars for them in ViewType.
	this.syty = syty;
	
	this.isOpen = !!isOpen;
	
	this.isOneLine = !!isOneLine;
	
	//TODO can (but careful of content types that can create infinite loops
	//crashing the browser tab, and of types that would be tried to save-as/download (popup)
	//executable file types, cuz fns can in theory make all possible file types and offer for download,
	//all from browser memory without files first existing on a drive)
	//...can display various file types in an iframe andOr img src= etc in the splat tree,
	//but put some checkboxes andOr warnings about downloading such files at time they're offered for download.
	//Such downloads are outside the sandbox as soon as they're named something other than .wikib
	//or .wikibinator203 or something like that (TODO choose file extensions .what to store lambdas).
	this.isLiteral = !!isLiteral;
	
	//Should the prefix dob display something like ]#NameXYZ or 3.141592653589793#Pi64 ?
	//#Names start with A-Z (1 char) but other than that can have any unicode symbols except whitespace []{}()<> etc.
	//Most strings other than that are themself as a stringLiteral such as hello in [hello world].
	//If it starts with 0-9 etc its a double literal.
	//TODO move some comments to isLiteral.
	//Most fns never have a name. Names are local to a VM and dont affect 256/512 bit globalIds or 128 bit localIds.
	//TODO name can be generated (choose random string starting with 1 char A-Z).
	//Name of a fn is different than the "var names" in loops, if/else, fork/kernel n ways, etc.
	//Those "var names" are normally string literals such as x y z こんにちは世界 etc.
	//Technically any fn can be such a "var name", even if its 1 of the exact values of pi (fn of digit index to digit),
	//but it seems more useful for names to be small strings.
	this.isDisplayName = !!isDisplayName;
	
	this.isDisplayPushAndPopChars = !!isDisplayPushAndPopChars;
	
	this.isDisplayChilds = !!isDisplayChilds;
	
	this.isFoldL = !!isFoldL;
	if(isFoldL && !isDisplayChilds) throw 'can only isFoldL if isDisplayChilds';
	
	this.isUnary = !!isUnary;
	if(isUnary && !isDisplayChilds) throw 'can only isUnary if isDisplayChilds';
	
	this.showDropDobs = !!showDropDobs;
	
	//get name from this.fn.n.nameEtc() which can be this.fn.n.localName or this.fn.n.locid(),
	//but you can only change this.fn.n.localName, and changing it might contradict the immutable design of Splate
	//and if so maybe Splate should be redesigned to have a name field. isDisplayName still chooses to display it or not.
	//In most fns/lambdas, name is not displayed. Its only displayed if need it to show 2 fns equal
	//or for a Human or AI to remember that fn.
	
	this.isSelected = !!isSelected;
	
	this.red = red;
	this.green = green;
	this.blue = blue;
	
};

var getSplit = (splate, leftSplit, rightSplit)=>{
	//TODO? dedup by aSplit.bigHash()? For now just return a new one and compare with aSplit.eq(split) which uses bigHash.
	return new Split(splate, leftSplit, rightSplit);
};

//perfect dedup of UI parts (not perfect deduping fn which is still using locid (128 bit localId) so only dedups by that)
//caches it the first time. Returns a text view of the contents, but not deeper into fn than its 128 bit localId.
Splate.prototype.bigHash = function(){
	return '[Splate_'+this.fn.n.locid()+'_'+this.syty+'_'+(this.isOpen?'O':'o')+(this.isOneLine?'L':'l')+(this.isLiteral?'I':'i')+
		(this.isDisplayName?'N':'n')+(this.isDisplayPushAndPopChars?'P':'p')+(this.isDisplayChilds?'C':'c')+(this.isFoldL?'S':'s')+
		(this.isUnary?'T':'t')+(this.isSelected?'S':'s')+'_R'+this.red+'_G'+this.green+'_B'+this.blue+']';
};

//compare splate to splate only.
Splate.prototype.eq = function(splate){
	return this.bigHash()==splate.bigHash();
};


//forkEdit. You probably should change syty and maybe some other things too if you change fn.
Splate.prototype.setFn = function(fn){
	let ret = this.copy();
	ret.fn = fn;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setSyty = function(syty){
	let ret = this.copy();
	ret.syty = syty;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setIsOpen = function(isOpen){
	let ret = this.copy();
	ret.isOpen = !!isOpen;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setIsOneLine = function(isOneLine){
	let ret = this.copy();
	ret.isOneLine = !!isOneLine;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setIsLiteral = function(isLiteral){
	let ret = this.copy();
	ret.isLiteral = !!isLiteral;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setIsDisplayName = function(isDisplayName){
	let ret = this.copy();
	ret.isDisplayName = !!isDisplayName;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setIsDisplayPushAndPopChars = function(isDisplayPushAndPopChars){
	let ret = this.copy();
	ret.isDisplayPushAndPopChars = !!isDisplayPushAndPopChars;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setIsDisplayChilds = function(isDisplayChilds){
	let ret = this.copy();
	ret.isDisplayChilds = !!isDisplayChilds;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setIsFoldL = function(isFoldL){
	let ret = this.copy();
	ret.isFoldL = !!isFoldL;
	if(ret.isFoldL && !ret.isDisplayChilds) throw 'can only isFoldL if isDisplayChilds, splate='+ret;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setIsUnary = function(isUnary){
	let ret = this.copy();
	ret.isUnary = !!isUnary;
	if(ret.isUnary && !ret.isDisplayChilds) throw 'can only isUnary if isDisplayChilds, splate='+ret;
	delete ret.bigHash_;
	return ret;
};



//forkEdit
Splate.prototype.setIsSelected = function(isSelected){
	let ret = this.copy();
	ret.isSelected = !!isSelected;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setRed = function(red){
	let ret = this.copy();
	ret.red = red;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setGreen = function(green){
	let ret = this.copy();
	ret.green = green;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setBlue = function(blue){
	let ret = this.copy();
	ret.blue = blue;
	delete ret.bigHash_;
	return ret;
};

//forkEdit
Splate.prototype.setRGB = function(red, green, blue){
	let ret = this.copy();
	ret.red = red;
	ret.green = green;
	ret.blue = blue;
	delete ret.bigHash_;
	return ret;
};



Splate.prototype.toString = function(){
	return this.toStringExceptFn()+'__fn='+this.fn;
};


//The "except fn" part is cuz displaying a fn could be very big.
Splate.prototype.toStringExceptFn = function(){
	return '[Splate syty='+this.syty+' isOpen='+this.isOpen+' isOneLine='+this.isOneLine+' isLiteral='+this.isLiteral+' isDisplayPushAndPopChars='+this.isDisplayPushAndPopChars+' isDisplayChilds='+this.isDisplayChilds+' isFoldL='+this.isFoldL+' isUnary='+this.isUnary+' isDisplayName='+this.isDisplayName+' name='+this.name()+']';
};

//if you call .name, it starts with A-Z (then any unicode chars) or Λ (locid). Locid is a 128 bit id created when the fn is created, but its string form is lazyEvaled.
//If its locid, then user hasnt given it a name. Doesnt trigger lazyeval of that string.
var nameOfFnIsLocid = fn=>fn.n.nameEtc_isLocid();

Splate.prototype.name = function(){
	return this.fn.n.nameEtc();
};

//throws unless vm.isValidLocalName(name)
Splate.prototype.setName = function(name){
	if(!vm.isValidLocalName(name)) throw 'Invalid localName['+name+']';
	this.fn.n.localName = name;
};

//UPDATE: js {} map of fn.n.locid() to {...various stuff about displaying that fn...}.
//
//OLD fnMeta_ comment:
//metadata/stuff about a fn, used in displaying it,
//especially remembering which Splates are views of a given fn.
//Its a Map (not a {}) of fn to {}. Map is slower than {} but can use any object as key.
//TODO optimize by using fn.n.locid() as key instead (but in vm theres only vm.cp(fn,fn)
//(which dedups by 2 locids (blobFrom blobTo idA idB, 2 of each of those), not 1 localid)?
//var fnMeta_ = new Map();
//I'm doing it by locid for speed (TODO verify its faster) and putting the fn in the val.
var fnMeta_ = {};

//Example: fnMeta(U(U(U))).numOpenSplates
//FIXME I'm trying to put all state into Split, so this should be used to choose what Splits to make, not as part of state.
var fnMeta = fn=>{
	//let ret = fnMeta.get(fn);
	let key = fn.n.locid();
	let ret = fnMeta_[key];
	if(!ret){
		ret = {
			//FIXME splat should adjust this when created and when splat is removed.
			//This is in rootSplat and dragSplat and everything reachable from them, FIXME should it only be rootSplat?
			numOpenNamedSplats: 0,
			
			//splates: [], //FIXME might need to use a treemap here (sorted by some arbitrary number in Splate, add that) if this list gets too big
			fn: fn,
		};
		//fnMeta_.set(fn,ret);
		fnMeta_[key] = ret;
	}
	return ret;
};



//FIXME you shouldnt need to copy a Splate since it should be used as immutable,
//but in this early prototype of the UI I'm modifying vars in it cuz forkEditing it isnt working yet.
Splate.prototype.copy = function(){
	return new Splate(this.fn, this.syty, this.isOpen, this.isOneLine, this.isLiteral, this.isDisplayName, this.isDisplayPushAndPopChars,
		this.isDisplayChilds, this.isFoldL, this.isUnary, this.showDropDobs, this.isSelected, this.red, this.green, this.blue);
};


/*
//makes a Splate of left child of fn, with everything open except if its U then closed.
//Normally you'll want to create a custom Splate, for custom ways to display it, but this is just to get started fast.
Splate.prototype.simpleLeftSplate = function(){
	return this.simpleLeftOrRightSplate(false);
};

Splate.prototype.simpleRightSplate = function(){
	return this.simpleLeftOrRightSplate(true);
};

Splate.prototype.simpleLeftOrRightSplate = function(isRight){
	if(this.fn.n.isLeaf()){
		return defaultSplate.copy(); //FIXME shouldnt need to copy, cuz should use as immutable.
	}else{
		
		let fn = (this.fn.n)[isRight ? 'R' : 'L']();
		let syty = fnToSyty(fn);
		let numOpenNamedSplats = fnMeta(this.fn).numOpenNamedSplats; //set by Splat, not by Splate.
		//FIXME what if forkEditing a Splate leaves that as 1 so !isOpen cuz a variant of itself is open that is about to be removed?
		let isOpen = numOpenNamedSplats===0;
		//let isDisplayName = false;
		let isDisplayName = true; //FIXME
		let isOneLine = true;
		let isLiteral = false;
		let isDisplayPushAndPopChars = !this.fn.n.isLeaf();
		//let showDropDobs = isOpen;
		let showDropDobs = false;
		let isSelected = false;
		//FIXME dont use random
		return new Splate(fn, syty, isOpen, isOneLine, isLiteral, isDisplayName, isDisplayPushAndPopChars, showDropDobs, isSelected, randRed(), randGreen(), randBlue());
	}
};
*/

//var randRed = ()=>(.45+.55*Math.random());
var randRed = ()=>(.55+.45*Math.random());
var randGreen = randRed;
var randBlue = randRed;



//all 3 params are optional
//TODO write new description now that theres both Split and Splat (old Split code was divided into that).
//var Split = function(fn, leftSplit, rightSplit, displayType, isOneLine){
//Renaming ViewType to Splate.
var Split = function(splate, leftSplit, rightSplit){

	this.splate = splate ? splate : defaultSplate.copy(); //FIXME shouldnt need to copy, cuz should use as immutable.
	
	//There can be 0 or more parents of Split cuz its an immutable forest, unlike Splaat which is a mutable tree.
	//Split therefore only knows its childs, down to whichever are viewed as closed (by #Name or localId or globalId).
	//A Split is itself open or closed
	this.leftSplit = leftSplit || null;
	this.rightSplit = rightSplit || null;
	
	
	/*
	//TODO How this Split is displayed depends on this.parentSplit.dity,
	//like parentSyty is used in in vm.ParseTree, vm.eval, etc.
	//fns/lambdas have no parent, but Splits do. Splits are a tree and not a forest. fns are both.
	this.parentSplit = parentSplit;
	this.leftSplit = leftSplit;
	this.rightSplit = rightSplit; throw 'TODO';
	*/
	
	
	
	/*FIXME how can Split be immutable and tell all 3 at once: parent, left, and right splits?
		And is there lazyEval of creating left and right Split childs when observed,
			cuz without that how would you look deeper into a very big forest of fns viewed by Splits?
	...
	I basically want forkEditable maps of fn to displayParams, except the fns can be duplicated,
	so maybe key is fn_with_arbitraryNumber?
	No, the map should use a fn and l l l r l r r l paths in it as key.
	I can make forkEditable treemaps, but the problem seems to be I want to be able to expand it on both ends,
	the parent direction and the childs direction.
	Need to copy these trees of Split and keep which parts are open/closed in the copy,
	make variants, mix them in various combos, etc.
	
	Here's the design (closer to it, todo keep fixing this...):
	A leaf Split is a closed view of a fn. A split can be made of any 2 Splits or be a leaf.
	Opening such a closed Split requires forkEdit all the way up the immutable tree of Split,
	which requires updating display of everything changed during that,
	but FIXME... FIXME... A dob cant have 2 parents, so either need to use immutable graphics,
	such as tree of y10x10rgb12 voxels with offset per branch, or make new dobs in the whole tree with each change.
	
	Pics as canvas bytes need to be cached somehow.
	Maybe fn.n.blob is a good enough cache, being the canvas bytes directly in some cases.
	I dont want to replace text on screen after every open/close, cuz it might interfere with which text is selected,
	but on the other hand you wont be actively using the text selection when you're opening/closing something.
	
	SOLUTION: Fixing this by dividing Split into 2 classes: Split (immutable, up from any closed leafs),
	and Splat (mutable, has dom nodes). Split.prototype.displayIn(Splat) fills in those dom nodes,
	and removes some dom nodes if they're no longer used.
	Split can share branches and is a forest (like fn). Split might be made of fns later (TODO?).
	Splat is a tree and cant share branches.
	A split is dragged from any part of Splat to any part of Splat.
	*/
	
	
	
	//'literal', 'localId', 'localName', 'hidden', or syty of fn, and maybe a few other possible values.
	//TODO choose shorter names for those such as 'lit' instead of literal.
	//This chooses if its displayed as open or closed, and if open then as canvas bytes, text, [], {}, (), <>, etc.
	//vm.ParseTree can give syty of a fn.
	////this.dity = displayType;
	
	////this.isOneLine = isOneLine;
	
	//FIXME where do height and width in pixels go for canvas bytes literal?
	
	//Moving this to Splat, so Split can be immutable forest, and Splat can be mutable tree with dom nodes.
	//map of string to dob (dom object)
	//this.dobs = {};
};

/*
//in pixels. doesnt have to be displayed. This is for use with isOneLine etc for first n childs in a []{}().
Split.prototype.estimateWidth = function(includeChildsIfExist){
	//cached from earlier call. Can do that cuz Split and Splate are used as immutable,
	//except for fn #LocalNames which are mutable but dont affect fn ids.
	if(includeChildsIfExist){
		if(this.estimateWidthWithChilds_ !== undefined) return this.estimateWidthWithChilds_;
	}else{
		if(this.estimateWidthWithoutChilds_ !== undefined) return this.estimateWidthWithoutChilds_;
	}
	let est = 0;
	if(this.splate.isLiteral){
		//FIXME better estimate literal size (could be 2.34 helloworld canvasbytes etc). Just making something up for now...
		let badlyEstimatedLiteralSize = options.estimatedFontWidth*8;
		est += badlyEstimatedLiteralSize;
	}else{
		if(this.splate.isOneLine){
			est += options.estimatedFontWidth*2; //{ and a later }, or [ and a later ], etc.
		}else{
			est += options.estimatedFontWidth*tabSizeInSpaces; //"{   " or "[   " etc.
		}
		if(this.splate.isOpen && this.leftSplit && this.rightSplit){
			if(this.splate.isFoldL){ //foldL means dont display left child (probably cuz prefix/suffix implies it. left child might be T or S)
				est += this.rightSplit.estimateWidth(includeChildsIfExist);
			}else{
				if(includeChildsIfExist){
					if(this.splate.isOneLine){
						est += this.leftSplit.estimateWidth(includeChildsIfExist)+this.rightSplit.estimateWidth(includeChildsIfExist);
					}else{
						est += Math.max(this.leftSplit.estimateWidth(includeChildsIfExist),this.rightSplit.estimateWidth(includeChildsIfExist));
					}
				}
			}
		}else{ //closed
			let nameSizeInChars = this.splate.name().length; //FIXME should this lazyeval of name be triggered?
			est += options.estimatedFontWidth*nameSizeInChars; //FIXME what does a closed branch look like? Just its name?
		}
	}
	if(includeChildsIfExist){
		this.estimateWidthWithChilds_ = est;
	}else{
		this.estimateWidthWithoutChilds_ = est;
	}
	return est;
};
*/

Split.prototype.isDisplayLeftChild = function(){
	let splate = this.splate;
	return splate.isOpen && this.leftSplit && !splate.isFoldL && !splate.isLiteral; //FIXME what if !isOpen and isLiteral?
};

Split.prototype.isDisplayRightChild = function(){
	let splate = this.splate;
	return splate.isOpen && this.rightSplit && !splate.isLiteral; //FIXME what if !isOpen and isLiteral?
};

//only computes it the first time.
//To clear that cache, set this.estimateWidthIfOneLine_ to null or undefined, but you'd only need that if name changed size (mutable localName in fn, FIXME).
Split.prototype.estimateWidthIfOneLine = function(){
	if(!this.estimateWidthIfOneLine_){
		let est = 0;
		let splate = this.splate;
		est += borderWidth*2;
		if(splate.isDisplayPushAndPopChars){
			if(splate.isLiteral) throw 'isLiteral AND isDisplayPushAndPopChars, splate='+splate;
			est += options.estimatedFontWidth*2;
		}
		if(this.isDisplayLeftChild()){
			if(!this.leftSplit) throw 'No leftSplit but isDisplayLeftChild said to display it';
			est += this.leftSplit.estimateWidthIfOneLine();
		}
		if(this.isDisplayRightChild()){
			if(!this.rightSplit) throw 'No rightSplit but isDisplayRightChild said to display it';
			est += this.rightSplit.estimateWidthIfOneLine();
		}
		if(splate.isLiteral){
			let literalString = toLiteralString(splate.fn);
			est += literalString.length*options.estimatedFontWidth;
			//let badEstimateOfLiteralWidth = 80;
			//est += badEstimateOfLiteralWidth;
		}
		if(splate.isDisplayName){
			let nameSizeInChars = this.splate.name().length; //FIXME should this lazyeval of name be triggered?
			est += options.estimatedFontWidth*(1+nameSizeInChars); //1+ cuz #. FIXME what does a closed branch look like? Just its name?
		}
		this.estimateWidthIfOneLine_ = est;
	}
	return this.estimateWidthIfOneLine_;
};

/*
//in pixels. doesnt have to be displayed. This is for use with isOneLine etc for first n childs in a []{}().
Split.prototype.estimateHeight = function(){
	throw 'TODO cache this in estimateHeight_, lazyevaled';
};
*/

Split.prototype.isOneLineDeep = function(){
	if(!this.isOneLineDeep_){
		let ret = this.splate.isOneLine;
		if(this.isDisplayLeftChild() && !this.leftSplit.isOneLineDeep()) ret = false;
		if(this.isDisplayRightChild() && !this.rightSplit.isOneLineDeep()) ret = false;
		//FIXME what if it cant be oneline cuz its a big canvas bytes literal etc?
		this.isOneLineDeep_ = ret;
	}
	return this.isOneLineDeep_;
}

Split.prototype.asOneLineDeep = function(){
	if(this.isOneLineDeep()) return this;
	let forkSplate = this.splate.setIsOneLine(true); //FIXME setIsOneLine should return same splate if already that way.
	let forkLeft = this.isDisplayLeftChild() ? this.leftSplit.asOneLineDeep() : this.leftSplit; //leave leftSplit as it is if not display it
	let forkRight = this.isDisplayRightChild() ? this.rightSplit.asOneLineDeep() : this.rightSplit; //leave rightSplit as it is if not display it
	return getSplit(forkSplate,forkLeft,forkRight);
};

//Returns a Split with everything the same as this one except some of the isOneLine might be changed (and maybe related things? are there any?).
//Using estimateWidth recursively, will set isOneLine where it can to try to not exceed the given maxWidth,
//but since a single thing can be wider than that, it might not be able to, but usually it will.
Split.prototype.forkTryMaxWidth = function(maxWidth){
	/*Fixing this with estimateWidthIfOneLine...
	FIXME todo make separate func to check if would fit as 1 line (optimize by giving maxWidth in case its big)
		and compare that to if it was displayed as multiline (which takes max of 2 child widths plus a bigger "tabbed over" prefix/suffix on left).
		If parent isOneLine then self must also be isOneLine. If parent is !isOneLine then self can be either.
		Also, some things cant be isOneLine, like a big canvas literal.
		Also, if self isOneLine and self isDisplayPushAndPopChars, that might make it a different size cuz of the "tabbed over"
			vs no added whitespace plus a prefix, the child(s), then suffix.
	*/
	console.log('forkTryMaxWidth maxWidth='+maxWidth+' fn='+this.splate.fn);
	let estSelfWidthIfOneLine = this.estimateWidthIfOneLine();
	//let estLeftWidthIfOneLine = this.leftSplit ? this.leftSplit.estimateWidthIfOneLine() : null;
	//let estRightWidthIfOneLine = this.rightSplit ? this.rightSplit.estimateWidthIfOneLine() : null;
	if(estSelfWidthIfOneLine <= maxWidth){
		return this.asOneLineDeep();
	}else{
		let maxWidthMinusTabbedOver = maxWidth-tabSizeInSpaces*options.estimatedFontWidth; //may be negative, but will just multiline if it exceeds such maxallowed
		let forkSplate = this.splate.setIsOneLine(false);
		let forkLeft = this.isDisplayLeftChild() ? this.leftSplit.forkTryMaxWidth(maxWidthMinusTabbedOver) : this.leftSplit; //leave leftSplit as it is if not display it
		let forkRight = this.isDisplayRightChild() ? this.rightSplit.forkTryMaxWidth(maxWidthMinusTabbedOver) : this.rightSplit; //leave rightSplit as it is if not display it
		return getSplit(forkSplate,forkLeft,forkRight);
	}
	
	
	

	/*
	console.log('forkTryMaxWidth maxWidth='+maxWidth+' fn='+this.splate.fn);
	let localWidth = this.estimateWidth(false);
	let maxChildsWidthAllowed = maxWidth-localWidth; //but still might be bigger than this if theres 1 literal deep in it thats bigger than this max
	console.log('forkTryMaxWidth localWidth='+localWidth+' maxChildsWidthAllowed='+maxChildsWidthAllowed);
	//If this.splate.isOneLine then add both childs to width, else add max of 2 child widths to width.
	//Calling forkTryMaxWidth (this recursively) on a child may return a less wide child by changing isOneLine in some parts of it.
	//FIXME how to know which to do isOneLine? Try to make them as wide as possible without going over the allowed max width?
	let iShouldBeOneLine;
	//let forkMe = this;
	//let mul = 1; //TODO
	let mul = .7; //FIXME
	let forkLeft = this.leftSplit ? this.leftSplit.forkTryMaxWidth(maxChildsWidthAllowed*mul) : null;
	let forkRight = this.rightSplit ? this.rightSplit.forkTryMaxWidth(maxChildsWidthAllowed*mul) : null;
	if(this.splate.isOpen && this.leftSplit && this.rightSplit){
		console.log('forkTryMaxWidth ISOPEN');
		let forkLeftSize = forkLeft.estimateWidth(true); //true include child splits if exist
		let forkRightSize = forkRight.estimateWidth(true);
		iShouldBeOneLine = (forkLeftSize+forkRightSize <= maxChildsWidthAllowed);
		console.log('forkTryMaxWidth ISOPEN forkLeftSize='+forkLeftSize+' forkRightSize='+forkRightSize+' iShouldBeOneLine='+iShouldBeOneLine);
	}else{
		//FIXME should set (by forkEdit) this.splate.isOneLine to true?
		iShouldBeOneLine = true;		
		console.log('forkTryMaxWidth ELSE');
	}
	//TODO optimize by doing setIsOneLine before getSplit makes another split.
	console.log('forkTryMaxWidth iShouldBeOneLine='+iShouldBeOneLine);
	let forkSplate = this.splate.setIsOneLine(iShouldBeOneLine);
	return getSplit(forkSplate,forkLeft,forkRight);
	//console.log('forkTryMaxWidth iShouldBeOneLine='+iShouldBeOneLine+' fn='+this.splate.fn);
	//return forkMe.setSplate(forkMe.splate.setIsOneLine(iShouldBeOneLine));
	//return forkMe.changeSplate(s=>s.setIsOneLine(iShouldBeOneLine));
	*/
};


//perfect dedup of UI parts (not perfect deduping fn which is still using locid (128 bit localId) so only dedups by that)
//caches it the first time. Returns a text view of the contents, but not deeper into fn than its 128 bit localId.
Split.prototype.bigHash = function(){
	if(!this.bigHash_){
		let hashMe = this.splate.bigHash();
		hashMe += this.leftSplit ? this.leftSplit.bigHash() : 'l';
		hashMe += this.rightSplit ? this.rightSplit.bigHash() : 'r';
		this.bigHash_ = 'Split_'+hashText(hashMe); //expensive calculation, todo use normal hashtable instead for speed.
	}
	return this.bigHash_;
};

Split.prototype.toString = function(){
	return '[Split_'+(this.leftSplit?'L':'l')+(this.rightSplit?'R':'r')+'_splate='+this.splate+']';
};


//do 2 Splits equal by deep content except fns are compared by their 128 bit localId (fn.n.locid()) not perfect deduped, true or false.
Split.prototype.eq = function(split){
	return this.bigHash()==split.bigHash();
};

//forkEdits this Split
Split.prototype.setSplate = function(splate){
	if(splate.eq(this.splate)){
		return this; //cuz Split and Splate should be used as immutable
	}else{
		//leftSplit and rightSplit may be null (if !this.isOpen, TODO verify?), but splate cant be.
		return getSplit(splate, this.leftSplit, this.rightSplit);
	}
};

//Example: aSplit.changeSplate(s=>s.setIsOneLine(true)) returns forkEdited aSplit whose splate.isOneLine is true,
//(TODO return that same aSplit if that was already true???)
Split.prototype.changeSplate = function(splateInSplateOut){
	return this.setSplate(splateInSplateOut(this.splate));
};


/* Since Split and Splate will have bigHash func, just use a js {} map of bigHash to that if you want dedup.
//Returns a deduped Split, given 2 deduped child Splits or nulls, but null childs are only allowed if !splate.isOpen.
var dedupSplit = function(splate, leftSplit, rightSplit){
	throw 'TODO';
};*/

/*
//a leaf split is closed. Otherwise, since fn is a fractal (every fn has 2 child fns that when called
//on eachother return that parent fn), it will expand forever into childs.
Split.prototype.isLeaf = function(){
	throw 'TODO get from this.dity';
};

Split.prototype.isDisplayPrefixAndSuffix = function(){
	throw 'TODO';
};

//Example: '['. Prefix and suffix are not always used, depending if parent is doing the prefix and suffix.
Split.prototype.prefix = function(){
	throw 'TODO';
};

//Example: ']#NameXYZ'. Prefix and suffix are not always used, depending if parent is doing the prefix and suffix.
Split.prototype.suffix = function(){
	throw 'TODO';
};
*/

//FIXME splits must not contain dobs, instead dobs are in splats.
//param is normally a div.
/*Split.prototype.displayIn = function(dob){
	//this.dity is a string. why is this code here? this.dity.dob = dob;
	dob.innerHTML = '';
	throw 'TODO';
};*/
/*Use Splat.setSplit instead of: Split.prototype.displayIn = function(splat){
	throw 'TODO';
};*/


Splat.prototype.splate = function(){
	return this.split.splate;
};

//FIXME move this to options.tabSizeInSpaces
//let tabSizeInSpaces = 10; //cuz the spaces are really small for some reason. FIXME why are they so small.
//let tabSizeInSpaces = 2; //cuz the spaces are really small for some reason. FIXME why are they so small.
let tabSizeInSpaces = 10; //cuz the spaces are really small for some reason. FIXME why are they so small.

//let borderWidth = 0;
let borderWidth = 2;
//let borderWidth = 3;
//let borderWidth = 5;
//let borderWidth = 9;
//let borderWidth = 13;

//only the dobs named in childDobNames per Splat.
Splat.prototype.putThisStringInAllEmptyDobsDeep = function(str){
	for(let dobName of childDobNames){
		let dob = this.dobs[dobName];
		if(dob){
			if(!dob.innerHTML){
				dob.innerHTML += str;
			}
		}
	}
	if(this.leftSplat){
		this.leftSplat.putThisStringInAllEmptyDobsDeep(str);
	}
	if(this.rightSplat){
		this.rightSplat.putThisStringInAllEmptyDobsDeep(str);
	}
	/*for(let dobName in this.dobs){
		let dob = this.dobs[dobName];
		if(!dob.innerHTML){
			dob.innerHTML += str;
		}
	}
	*/
};

//A root is height 0. Direct child of root is height 1, and so on.
Splat.prototype.height = function(){
	return this.parentSplat ? (1+this.parentSplat.height()) : 0;
};

//remove padding from dob/domObject, then return that same dob
var unpad = function(dob){
	let s = dob.style;
	//s.color = 'blue';
	s.paddingTop = 0;
	s.paddingRight = 0;
	s.paddingBottom = 0;
	s.paddingLeft = 0;
	/*s['padding-top'] = '0px';
	s['padding-right'] = '0px';
	s['padding-bottom'] = '0px';
	s['padding-left'] = '0px';
	*/
	//s.padding = '0px';
	switch(dob.tagName){
		case 'TABLE':
			attr(dob,'cellSpacing',0);
			//dob.border = 0;
		break;case 'TR':case 'TD':
			
			
		break;case 'DIV':
		default:
	}
	return dob;
};

//FIXME should have max chars to return, in case very big, dont want to recurse deep making a huge string.
var toLiteralString = fn=>{
	let literal;
	if(fn.n.isDouble()){
		//normal javascript double toString, which is same as java double toString except maybe how exponent
		//is displayed with or without + and leading zeros in it etc, todo verify.
		literal = ''+fn.n.d();
	}else if(fn.n.isTypeUtf8()){
		let content = fn.n.r;
		let utf8Bytes = content.n.bytes();
		
		//The next 3 comment lines are copied from VM:
		//FIXME quote it if it contains whitespace or ( ) { } [ ] < > , or certain other chars or depending on size.
		//If it starts with a lowercase letter or most of the other unicode chars then it can be a string literal without quotes.
		//If it starts with a capital A-Z then its a #Name. If you want other unicode chars in a #Name then just prefix with 1 of A-Z.
		
		literal = vm.utf8AsUint8ArrayToString(utf8Bytes);
	}else if(fn.n.isCbt()){
		literal = vm.cbtToHex(fn);
	}else{
		throw 'TODO what literal type? fn='+fn;
	}
	return literal;
};


//displays it deeply but not past Splats whose Split is equal (Split.eq(Split)) cuz would in theory be the same graphics etc.
//
//WARNING: When left child is vm.ops.Infcur (aka displayed as [] by itself, or [a b c] to mean ([] a b c)) theres no this.leftSplat
//but there is this.rightSplat, but both Split childs are there. The left split child is normally closed if its [].
//Also could that happen in a rightSplat too if that happens to be []?
//
Splat.prototype.setSplit = function(split){
	if(!split) throw 'No split';
	var prevSplit = this.split;
	if(!prevSplit) throw 'No prevSplit';
	const isAllNbsp = /^(\&nbsp\;)*$/;
	if(!split.eq(prevSplit)){
		this.split = split;
		if(!this.dobs.self) throw 'No self dob';
		let prevSplate = prevSplit.splate;
		let splate = split.splate;
		
		if(options.displayOnly_setSplit_inLiteral){
			this.dobs.literal.innerHTML = 'setSplit param='+split;
		}
		
		let style = this.dobs.self.style;
		style.borderStyle = 'outset';
		style.display = 'inline-block';
		let red = splate.red;
		let green = splate.green;
		let blue = splate.blue;
		let brightMul = .85;
		if(this.isSelected()){
			console.log('isSelected splat='+this);
			red = green = blue = 1;
		}
		style.backgroundColor = colorStr(red*brightMul,green*brightMul,blue*brightMul);
		//style.borderWidth = '15px';
		style.borderWidth = borderWidth+'px';
		//FIXME borderWidth of 0 is still getting a little tilt, is not displayed as 0
		style.borderColor = colorStr(red,green,blue);
		
		//this.dobs.self.title = 'test';
		let popupTitle = '';
		
		let syty = splate.syty;
		let fn = splate.fn;
		
		if(splate.isLiteral){
			let literal = toLiteralString(splate.fn); //FIXME with max size in chars
			this.dobs.literal.innerHTML = options.literalPrefix+literal+options.literalSuffix;
		//}else if(splate.isDisplayPushAndPopChars && !splate.isFoldL){ //FIXME isFoldL shouldnt be checked here
		}else if(splate.isDisplayPushAndPopChars){ //FIXME isFoldL shouldnt be checked here
			let prefix = '<b>'+sytyToPushChar(syty)+'</b>';
			let suffixfarright = '';
			for(let i=tabSizeInSpaces-prefix.length; i>0; i--) prefix += '&nbsp;'; //TODO optimize all one string, not loop
			let suffix = '<b>'+sytyToPopChar(syty)+'</b>';
			for(let i=tabSizeInSpaces-suffix.length; i>0; i--) suffix += '&nbsp;'; //TODO optimize all one string, not loop
			if(splate.isDisplayName){
				//suffix += '#TODONAMEHERE';
				suffix += '#'+splate.name();
			}
			
			if(splate.isOneLine){
				//put suffix in dobs.upfarright (rightmost of 3 tds in same tr) instead of dobs.suffix (aka downleft)
				suffixfarright = suffix;
				suffix = '';
			}else{
				//let suffixVerticalAlign = 'bottom';
				if(splate.isUnary && splate.isDisplayChilds){
					//Example: prefix is ',' as in (T abc) being displayed as ,abc but the ',' is displayed at top of suffix dob
					//instead of top of prefix dob, so the 2x2 table that has prefix at topleft and suffix at bottomleft, has empty top row,
					//and at topright would be T aka , but cuz of isFoldL it doesnt display that. See options.isFoldT.
					//suffix = prefix;
					//prefix = '';
					//suffixVerticalAlign = 'top';
					suffix = '';
				}
				//this.dobs.suffix.style.verticalAlign = suffixVerticalAlign;
				
				let isBigSuffix = splate.isDisplayName;
				if(isAllNbsp.test(suffix)){
					suffix = '';
				}
				if(isBigSuffix){
					this.dobs.suffixb.innerHTML = '';
					this.dobs.suffixc.innerHTML = suffix;
				}else{
					this.dobs.suffixb.innerHTML = suffix;
					this.dobs.suffixc.innerHTML = '';
				}
			}
			
			// /^(\&nbsp\;)*$/.test('&nbsp;&nbsp;&nbsp;') returns true
			if(isAllNbsp.test(suffixfarright)){
				//Is all nobreakspaces, so dont put that in dobs.upfarright so it wastes less screen space.
				//This happens when isUnary.
				
				suffixfarright = '';
				
			}
			
			this.dobs.prefix.innerHTML = prefix;
			this.dobs.suffixfarright.innerHTML = suffixfarright;
			
			//this.dobs.suffixfarright = suffix;
			
			
			if(splate.showDropDobs){
				this.dobs.dropleft.innerHTML = '(dropleft)';
				this.dobs.dropmid.innerHTML = '(dropmid)';
				this.dobs.dropright.innerHTML = '(dropright)';
			}
		}else if(!splate.isFoldL && splate.isDisplayName){ //FIXME set isDisplayName to false when making splate, depending on what, instead of checking isFoldL here?
			this.dobs.prefix.innerHTML = '';
			this.dobs.suffixfarright.innerHTML = ''; //where suffix text goes (instead of dobs.suffix) if isOneLine
			//FIXME should this go in suffix if its name? thats where name usually goes, but if its ONLY name, maybe it should go in literal?
			let literal = splate.name();
			this.dobs.literal.innerHTML = options.namelitPrefix+literal+options.literalSuffix;
			//this.dobs.suffix.innerHTML = '';
		}//else{
		//	this.dobs.literal.innerHTML = 'FIXME_whatGoesInThisElse';
		//}
		
		//flex-direction: row row-reverse column colum-reverse
		this.dobs.upright.style['flex-direction'] = splate.isOneLine ? 'row' : 'column'; //https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction
		
		if(options.displayEstimateWidth){
			popupTitle += '__estimateWidthIfOneLine='+this.split.estimateWidthIfOneLine();
		}
		
		if(options.displayWholeTostringAtEachRect){ //for testing
			//suffix += '__'+splate.fn;
			popupTitle += '__fn='+splate.fn;
		}
		if(options.displaySplateDetailExceptFnAtEachRect){ //for testing
			//suffix += '__'+splate.toStringExceptFn();
			popupTitle += '__'+splate.toStringExceptFn();
		}
		if(options.display_isSelected_afterName){
			//suffix += '__isSelected='+this.isSelected();
			popupTitle += '__isSelected='+this.isSelected();
		}
		if(options.displaySplatHeight){
			popupTitle += '__height='+this.height();
		}
		if(options.displaySplatPathFromRoot){
			popupTitle += '__path='+this.pathFromRoot();
		}
		
		if(popupTitle) this.dobs.self.title = popupTitle;

		if(splate.isFoldL){
			//foldS means display (S (S a b) c) as {a b c}, as vararg {...}.
			//Just display right child, not left child or anything else except maybe still display controls etc.
			if(!splate.isDisplayChilds) throw 'can only isFoldL if isDisplayChilds, splate='+splate;
			
			if(options.displayDebugInfoAboutVarargS){
				this.dobs.left.innerHTML = '(hidden by foldS)';
			}else{
				this.dobs.left.innerHTML = '';
			}
			//dont display leftSplat in this.L() cuz isFoldL hides S.
			this.R().setSplit(this.split.rightSplit);
		}else{		
			//if(this.split.splate.isOpen && this.split.leftSplit && this.split.rightSplit){
			if(this.split.splate.isDisplayChilds && this.split.leftSplit && this.split.rightSplit){
				//this.L() creates or reuses this.leftSplat, similar for .R()
				console.log('Splat displaying left child');
				//this.L().displayIn(this.dobs.left);
				this.L().setSplit(this.split.leftSplit);
				console.log('Splat displaying right child');
				//this.R().displayIn(this.dobs.right);
				this.R().setSplit(this.split.rightSplit);
			}
		}
	}
};

/*
Splat.prototype.displayLocal = function(){
	console.log('Splat displayLocal this='+this);
	if(!this.dobs.self) throw 'No self dob';
	this.updateSelfDivStyle();
	let syty = this.splate.syty;
	if(this.splate.isDisplayPushAndPopChars){
		if(syty == 'U'){
			throw 'Dont look into the fractal (L U (R U))->U, isDisplayPushAndPopChars should be false and isDisplayName true and name should be U.';
		}
		let prefix = sytyToPushChar(syty);
		let suffix = sytyToPopChar(syty);
		//let prefix = syty=='U' ? '' : sytyToPushChar(syty);
		//let suffix = syty=='U' ? '' : sytyToPopChar(syty);
		//if(syty=='U' && !this.splate.isDisplayName){
		//	throw 'Must display name if its U
		//}
		if(this.splate.isDisplayName){
			//suffix += '#TODONAMEHERE';
			suffix += '#'+this.splate.name();
		}
		if(options.displayWholeTostringAtEachRect){
			suffix += '__'+this.splate.fn;
		}
		if(options.displaySplateDetailExceptFnAtEachRect){
			suffix += '__'+this.splate.toStringExceptFn();
		}
		suffix += '__isSelected='+this.isSelected();
		this.dobs.prefix.innerHTML = prefix;
		this.dobs.suffix.innerHTML = suffix;
	}else{
		if(syty == 'U'){
			if(!this.splate.isDisplayName){
				throw 'Must isDisplayName for leaf/U';
			}
		}
	}
};*/

/*
Splat.prototype.removeDobs = function(){
	for(let dobName in this.dobs){
		this.dobs[dobName].remove(); //remove from dom tree
		delete this.dobs[dobName];
	}
};

Splat.prototype.displayIn = function(dob){
	if(!dob) throw 'No param dob';

	//TODO merge duplicate code between displayIn and displayLocal

	console.log('Splat displayIn '+dob);
	const ThisSplat = this;
	if(this.dobs.self != dob){
		console.log('Splat replacing its dobs');
		dob.innerHTML = '';
		dob.addEventListener(
			'click',
			function(event){
				//console.log('click '+ThisSplat);
				//requestAnimationFrame(function(){
					//console.log('ThisSplat_isRoot='+(ThisSplat===rootSplat));
					setSelSplat(ThisSplat);
				//});
				event.stopPropagation();
			}
		);
		this.removeDobs();
		this.dobs.self = dob;
		this.createDobsIfNotExist();
		this.displayLocal();
	}
	if(this.splate.isOpen){
		//if(this.leftSplat){
			console.log('Splat displaying left child');
			//this.leftSplat.displayIn(this.dobs.left);
			this.L().displayIn(this.dobs.left);
		//}
		//if(this.rightSplat){
			console.log('Splat displaying right child');
			//this.rightSplat.displayIn(this.dobs.right);
			this.R().displayIn(this.dobs.right);
		//}
	}
};
*/

/*
var newSplateForFnAsRoot = function(fn){
	let syty = fnToSyty(fn);
	//FIXME should depend on parent syty, or parent of parent of parent... How did VM do it? Check vm.View.prototype.syty.
	let isDisplayPushAndPopChars = true;
	return new Splate(fn, syty, true, false, false, false, isDisplayPushAndPopChars, false, randRed(), randGreen(), randBlue()); //FIXME which true/falses?
};*/



var fnToView = fn=>vm.getViewer().view(fn);



//creates sytys all the way down, on L and R childs of fn, but (FIXME verify) not past blob wrappers,
//and FIXME it should depend on splate.isOpen etc and maybe that of its childs (if parent isOpen but not 1 or both of its childs).
var fnToSyty = fn=>fnToView(fn).syty();


var fnIsLiteral = fn=>(fn.n.isCbt() || fn.n.isDouble() || fn.n.isTypeUtf8());

//experimental cuz theres lots of isOpen, which could use alot of screen space with duplicate views of same fn, as fn is a forest.
//This is replacing newSplateForFnAsRoot but better cuz its stateless and doesnt have to be root, can be for any Splat in tree of Splats.
//
//Remember, a Split is immutable and can have many parents,
//but a Splat is mutable (its only state is Splate and dobs/domObjects derived from Splate) and can have at most 1,
//and Split and Splat both contain only Splate and childs (of same type, Split vs Splat).1
//
//optionalCallerSyty defaults to 'C'. VM says "C is normal call (a b c d e) aka ((((a b) c) d) e)".
//
//the callerSyty and isRightRecursion are similar to this code in prototype VM:
//	vm.Viewer.prototype.viewToStringRecurse = function(view, viewing, callerSyty, isRightRecursion)
//
var newSplitForFn_experimental = function(fn, optionalCallerSyty, optionalIsRightRecursion){
	let callerSyty = optionalCallerSyty || 'C';
	let isRightRecursion = !!optionalIsRightRecursion;
	let syty = fnToSyty(fn);
	//FIXME should depend on parent syty, or parent of parent of parent... How did VM do it? Check vm.View.prototype.syty.
	let isOpen = fn!==U; //aka !fn.n.isLeaf(). U is the universal combinator/lambda.
	//FIXME should there be a level of isOpen that just displays literal but not childs? literal could be big, so closed, literalOnly, open, could be 3 levels?
	let isOneLine = false;
	if(options.displayAllAsOneLine || (options.displayAllAsOneLineRandomlyTrueOrFalsePerBranch && Math.random()<.6)){
		isOneLine = true;
	}
	//let isLiteral = false;
	let isLiteral = fnIsLiteral(fn);
	//let isDisplayName = true;
	//FIXME, use name anyways (locid) if need a name to display the same fn multiple places (split can have multi parents, splat cant).
	let isDisplayName = !nameOfFnIsLocid(fn);
	if(isDisplayName){
		isOpen = false;
	}
	let isDisplayPushAndPopChars = isOpen && !isLiteral;
	let isDisplayChilds = isDisplayPushAndPopChars; //FIXME
	let isFoldL = false;
	let isUnary = false; //if true, display (T abc) as ,abc
	if(options.displayVarargLists && (syty=='IC+' || syty=='IC0') && syty == 'IC+' && !isRightRecursion){
		isDisplayPushAndPopChars = false;
		/*
		switch(syty){
			//isDisplayChilds can still be true, while this is false, which (TODO) happens to display {} [] () <> as vararg syntax.
			case 'IC+': //a call of Infcur aka [] aka a vararg list. syty IC0 is [] aka an empty list.
				//[] / Infcur list
				isDisplayPushAndPopChars = false;
			break;case 'C':case 'S1':
				//normal call pair
				isDisplayPushAndPopChars = false; //isDisplayChilds can still be true, while this is false, which (TODO) happens to display {} [] () <> as vararg syntax.	
			break;case 'S2':
				//FIXME only display fn.n.L().n.R() and fn.n.R(), but NOT fn.n.L().n.L() which is vm.ops.S. This is {...} syntax aka sCurryList.
				throw 'TODO';
			default:
				throw 'FIXME, unknown syty='+syty;
		}*/
	}else if(options.displayVarargNormalCallPairs && (callerSyty == 'C' || callerSyty == 'S0') && (syty == 'C' || syty == 'S1')){
		isDisplayPushAndPopChars = false;
	}else if(options.displayVarargS && callerSyty == 'S2' && syty == 'S1' && isDisplayChilds){
		isFoldL = true;
		isDisplayPushAndPopChars = false;
		//isDisplayName = false; //FIXME what if need the name cuz multiple parents are displayed?
		//if(callerSyty == 'S1'){ //FIXME?
		//	isDisplayPushAndPopChars = false;
		//}
		//isDisplayPushAndPopChars = false; //FIXME??
	}else if(options.displayVarargS && syty == 'S2' && callerSyty == 'S1' && isDisplayChilds){
		isDisplayPushAndPopChars = false;
		//isDisplayName = false; //FIXME what if need the name cuz multiple parents are displayed?
	}
	
	if(options.displayVarargNormalCallPairs){
		if(syty=='C' && callerSyty=='C' && isDisplayChilds){
			//Display as (abc def ghi) instead of ((abc def) ghi)
			isDisplayPushAndPopChars = false;
		}
	
	}
	
	
	
	if(options.displayVarargLists && (syty=='IC0' || syty=='IC+') /*&& callerSyty=='IC+'*/ && isDisplayChilds){
		//FIXME should have 3 sytys for Infcur/[] (IC0 and IC1 and IC2+), instead of 2 (IC0 and IC+),
		//so dont have to check if left is IC0 here.
		
		let leftSyty = fnToSyty(fn.n.L()); //FIXME avoid triggering lazyEval of creating fn.n.l? Does this ever do that? Thats mostly for blobs.
		if(leftSyty == 'IC0'){
			//aka left is Infcur/[]. Display as [abc] instead of ([] abc) aka instead of (Infcur abc).
			isFoldL = true;
			//isDisplayPushAndPopChars = false;
		}	
	}
	
	if(options.foldT && syty=='T1' && isDisplayChilds){
		isFoldL = true;
		isUnary = true;
	}
	
	//let showDropDobs = isOpen;
	let showDropDobs = false;
	let isSelected = false;
	let red = randRed(); //FIXME should be deterministic
	let green = randGreen(); //FIXME should be deterministic
	let blue = randBlue(); //FIXME should be deterministic
	let splate = new Splate(fn, syty, isOpen, isOneLine, isLiteral, isDisplayName, isDisplayPushAndPopChars, isDisplayChilds, isFoldL, isUnary, showDropDobs, isSelected, red, green, blue);
	let leftSplit = null;
	let rightSplit = null;
	//if(isOpen && isDisplayPushAndPopChars){
	if(isDisplayChilds){
		leftSplit = newSplitForFn_experimental(fn.n.L(),syty,false); //callerSyty
		rightSplit = newSplitForFn_experimental(fn.n.R(),syty,true); //callerSyty
	}
	return getSplit(splate,leftSplit,rightSplit);
};


//this is for U.
var defaultSplit = newSplitForFn_experimental(U);
//var defaultSplate = new Splate(U, 'C', false, true, false, true, false);




/*
//draggable tree node, view of a fn/lambda as a var size list or literal. Literals can be text, sounds, canvas bytes, etc.
var Branch = function(split){

	FIXME, should Branch be immutable (other than maybe some dob/domObject optimizations)?
	Yes, do that. But optimize for reusing canvas(es) for low lag cuz changing dom tree maybe is not as fast as video frames in canvas.
	Might cause a problem with renaming #Names after theyre displayed.
	Maybe Names and literals(like a pic displayed in canvas, changing every 1/60 second for interactive video) should
	be in a separate js type than Branch, so they can update on their own, without changing size, and without interfering
	with the Branch objects?
	Should each Branch take a height and width in its constructor, maybe in units of monospaced chars?
		That could be a problem for magnifying/shrinking big names to fit in the same space.
	Imagine dragging a Branch (a rectangle on screen) onto another Branch to call it, in {} [] () or <>.
		Just making the tree causes the call.
	Fixing some of that using the Split class which is an immutable view of 
		
	
	
	//this.fn = fn;
	this.split = split;
	
	//or if its displayed as just a Name# (defined somewhere else) then no prefix or suffix.
	this.prefix = ''; //Examples: [ { ( <
	this.suffix = ''; //Examples: ] } ) >
	
	//dom object, maybe a div. div may contain canvas andOr child Branchs.
	//Contains childsDob and maybe other stuff (such as displaying this.prefix and this.suffix left of it tabbed over).
	this.dob = null;
	
	this.prefixDob = null;
	
	//TODO move Name# to end instead of start, so its (...)#Name, cuz theres more room on the closing paren/etc, often in its own line.
	//and cuz you cant use #Name before its (...) is defined, so you cant create cycles in the lambda forest.
	this.nameDob = null;
	
	//may be a canvas or text or 0x45f9 cbt or 2.34 number or localId or globalId etc.
	//This must be used if !this.treeOpen
	this.literalDob = null;
	
	//inside this.dob, near this.prefix. controlsDob has a checkbox to change this.treeOpen
	//and maybe other controls to change how things are displayed.
	//TODO where is this.fn dragged from?
	this.controlsDob = null;
	
	//tabbed over 1 tab to the right of this.prefix, and this.suffix is down right from childsDob and is on its own line,
	//or if its all on 1 line then childsDob is between this.prefix on its left and this.suffix on its right with no tabs.
	//childsDob contains all Branchs in this.childs, if this.treeOpen, else is empty/hidden/etc.
	this.childsDob = null;
	
	this.suffixDob = null;
	
	FIXME should there be Branch for every fn or just one per var size list?
	
	//child Branchs. They may or may not be displayed.
	this.childs = [];
	
	//If false, this is displayed as this.fn.n.locid() (string form of 128 bit local id). If true, childs are displayed.
	this.treeOpen = true;
	
	//If childs fit on 1 line, then set this to true. Starts false in case they dont,
	//since fn hasnt been tostringed to know how big its code is, which parts are displayed etc.
	//If one line, then this.prefix is leftmost and this.suffix is rightmost (around other contents) in same line.
	this.isOneLine = false;
};

Branch.prototype.display = function(){
	throw 'TODO';
};
*/

//a root splat, such as rootSplat or dragSplat.
Splat.prototype.isRoot = function(){
	return !this.parentSplat;
};

Splat.prototype.isRightChild = function(){
	return this.parentSplat && this.parentSplat.rightSplat===this;
};

Splat.prototype.pathFromRoot = function(){
	if(this.isRoot()) return 'X';
	return this.parentSplat.pathFromRoot()+(this.isRightChild() ? 'R' : 'L');
};

//returns a Split for use in a root Splat, cuz Splat is mutable and Split and Splate are used as immutable.
//UPDATE: param is a split, not a splate. If you want a splate instead, you can reuse the 2 child splits with a different splate here.
//goes all the way up to a root splate (such as rootSplat or dragSplat).
//Returns a Split that you'd use in thatRoot.setSplit, that has deep inside it this splat's splate set to the given splate.
//Split is (used as) immutable and can have multi parents. Splat is mutable and has at most 1. Both have a splate.
Splat.prototype.forkRootSplit = function(replaceWithThisSplit){
	if(!this.parentSplat){ //this is root
		return replaceWithThisSplit;
	}
	let isRightChild = this.parentSplat.rightSplat===this;
	let nextSplit;
	if(isRightChild){
		nextSplit = getSplit(this.parentSplat.split.splate, this.parentSplat.leftSplat.split, replaceWithThisSplit);
	}else{ //is left child
		nextSplit = getSplit(this.parentSplat.split.splate, replaceWithThisSplit, this.parentSplat.rightSplat.split);
	}
	return this.forkRootSplit(nextSplit);
	//throw 'TODO use this when "TODO use setSplit but must forkEdit which is selected first"';
};

//returns a Split for use in a root Splat, cuz Splat is mutable and Split and Splate are used as immutable.
Splat.prototype.forkRootSplate = function(replaceWithThisSplate){
	/*fixmefixme return this.setSplate(replaceWithThisSplate)
	Split.prototype.setSplate = function(splate){
	*/
	throw 'TODO call forkRootSplit with the existing 2 child splits, if they exist, else nulls for those';
};

//get a string of js code that returns me, something like 'rootSplat.L().R().R()'
Splat.prototype.ptr = function(){
	if(this.isRoot()){
		if(this === rootSplat) return 'rootSplat';
		if(this === dragSplat) return 'dragSplat';
		throw 'Unknown root splat: '+this;
	}
	return this.parentSplat.ptr()+(this.isRightChild() ? '.R()' : '.L()');
};

//selected splat else null if none is selected
var selSplat = null;

//null to unselect
var setSelSplat = splat=>{
	console.log('setSelSplat '+splat);
	console.log(splat.ptr());
	let prevSelSplat = selSplat;
	selSplat = splat;
	if(prevSelSplat && prevSelSplat != selSplat) prevSelSplat.displayLocal();
	throw 'TODO use setSplit but must forkEdit which is selected first';
	//selSplat.displayLocal();
	//rootDisplay(true);
};

//display rootSplat in rootDob, the main rectangle that Wikibinator203 fns/lambdas are viewed and drag-and-drop to call in.
//var rootSplat = new Splat(null, newSplateForFnAsRoot(exampleFnToDisplay));
var rootSplat = null; //cuz need rootDob to exist first, and not doing that til window.onload
//var rootSplat = new Splat(null, newSplateForFnAsRoot(exampleFnToDisplay));
//rootSplat.split = newSplitForFn(exampleFnToDisplay);
var rootDob = null; //TODO


/*TODO how will Split and Splat do the graphics of dragging, during the drag?
I want it to show either a small icon or a whole splat, during the drag.
Maybe I should include extra divs, normally empty, in every Splat, in every
possible place in that splat it could be dropped (UPDATE: those are dropleft, dropmid, and dropright),
including hidden splats?
Or maybe there should be a second rootSplat-like var called dragSplat?
Do both, and keep moving dragDob, which dragSplat is displayed in,
to these drop target dobs in the splats.
Once dropped, it forkEdits rootSplat.split and displays that in rootSplat,
and maybe there will be an undo button and history for going way back
andOr some quicksave and quickload buttons etc.
Any split should display the same even if its loaded again,
and maybe later I'll make it be made completely of fns instead of a split just wrapping a fn.
*/
var dragSplat = null; //TODO when dragging
var dragDob = null; //dragSplat.displayIn(dragDob). rootSplat.displayIn(rootDob).

/*
//expensive calculation
Splat.prototype.displayDeep = function(){
	if(!this.dobs.self) throw 'No self dob in '+this;
	this.removeDobsExceptSelf();
	this.displayIn(this.dobs.self);
	if(this.splate.isOpen){
		this.L().displayIn(this.dobs.left);
		this.R().displayIn(this.dobs.right);
	}
};
*/

/*
var rootDisplay = ()=>{
	console.log('rootDisplay');
	if(rootSplat.dobs.self){
		rootSplat.displayDeep();
	}else{
		rootDob = Dob('rootDob');
		rootSplat.displayIn(rootDob); //FIXME is this compatible with split.displayIn(splat)?
	}
};*/




var Dob = id=>document.getElementById(id);

//display rootSplat in rootDob, the main rectangle that Wikibinator203 fns/lambdas are viewed and drag-and-drop to call in.
//var rootSplat = new Splat(null, newSplateForFnAsRoot(exampleFnToDisplay));
var rootSplat = null; //cuz need rootDob to exist first, and not doing that til window.onload
//var rootSplat = new Splat(null, newSplateForFnAsRoot(exampleFnToDisplay));
//rootSplat.split = newSplitForFn(exampleFnToDisplay);
var rootDob = null; //TODO


/*/////////////////////////////////////////////////////////////////////////////////////

//This script is under the Wikibinator203 license.

//This is a different wikibinator203 tree UI I'm trying, where each UI node knows its exact pixel width and height
//and literals (including canvas bytes, #Names, 2.34 numbers, stringLiterals 'string literals' etc,
//can be displayed using dom nodes (dobs) but still must be an exact size,
//and I want to redesign the localName system so its not used here as a mutable string var in fn/lambda but is
//a specific data in these UI nodes (even if its still used that way in fns, all data in these UI nodes must be used as immutable,
//so if you change that localName in the fn this UI is still displayed correctly.
//Or maybe I want per pixel precision everywhere instead of using dom nodes at all? Start coding this and figure it out... (TODO)
//and maybe it should just store the 128 bit localId of fn instead of the fn itself?
//(but vm.cp(fn,fn) looks up fn by its 2 child fns for dedup, using 2 id128s, not a single id128)

//or maybe... NEVERMIND, JUST USE Split and Splate and Splat mostly as they are, but with exact width and height.
//If I know exact width and height, then dont need a table tr td etc to position childs and prefix suffix etc
//and instead could set the exact 2d positions and sizes of all those as child divs.
//It might create a problem putting normal dom objects inside it, like an iframe to view a pdf (as bytes, not file)
//but for sandboxing, it shouldnt have anything that can infinite loop etc (even if otherwise sandboxed)
//so canvas and text and a few other "literal viewers" are probably
//all it needs (and could still generate a pdf editor in canvas since its turing complete, if wanted that for example).
TODO that... Get rid of the table tr td but still use the same Splat.dobs (with less stuff in it),
and use overflow:hidden (or what was that) on everything, and position everything deterministicly.
Maybe have just 1 drop dob per Splat and move it around as needed, since drop events will be at a (y,x) at root dob
instead of its tree of child dobs/Splats.

TODO merge this into existing Splate

TODO change to all divs with overflow:hidden and being made an exact size, and get rid of the table tr td in splatdobs.

TODO only display literals as dobs, dont display splats as dobs. Have 1 div containing all of them to get dom events
and do math to figure out which part of the tree (which is not made of dom nodes except the literals) that (y,x) is at.
Have recursive 2d (so 6 numbers) affine transform recursively (or just dy and dx, 2 numbers? that would be simpler)
tree nodes. Also have css clip path so could for example display a 2d triangle polygon or scroll window etc.
For now, just 2 numbers (dy and dx) per child should be enough,
and have a func (only compute it on first call) for width and func for height. Per child.


//MovedOb of a SplitB or a SplatetB, at a y and x offset like a subwindow.
var MovedOb = function(dy, dx, ob){
	this.dy = dy;
	this.dx = dx;
	this.ob = ob;
};

var SplitB = function(){
	//map of string to MovedOb of child SplitB. Those strings are like 'left' 'right' 'prefix' dropmid' etc.
	this.childs = {};
	//this.data = null; //TODO if its canvas bytes or text etc, what to display instead of childs, if isLiteral.
};

var SplateB = function(){
	FIXME these comments may have got split splate splat etc mixed up, rewrite...
	same stuff as Splate (doesnt need redesign?) plus I'm moving SplitB.data to be SplateB.data instead
	//or maybe leave this in splate.fn.n.blob in byte range splate.fn.n.blobFrom or splate.fn.n.blobTo-1
	//(or it may not have a blob and be the slow way of computing that blob from the universal lambda,
	//tree expanded instead of wrapping a blob, or even if there is a blob it can be both sparsely).
	this.data = null; //TODO if its canvas bytes or text etc, what to display instead of childs, if isLiteral.
};
SplatB.prototype.setSplate

/*

//like a Split (in other code), immutable, can have many parents, no parent ptr. Knows its exact pixel size.
var Branch = function(h, w){
	this.h = h; //height
	this.w = w; //width
	TODO y and x offsets per child. or what about using css transform numbers (such as 6 numbers, or 16 numbers?) to scale rotate etc each child?
	this.c = []; //child Branches
	//this.l = null; //TODO: left child Branch, or may be null (or nonnull) if !isOpen
	//this.r = null; //TODO: right child Branch, or may be null (or nonnull) if !isOpen
	TODO where does the literal data go such as canvas, 2.34, stringLiteral, etc?
	TODO how do drag events work? How could it be used to make a canvas inside this tree, that implements some other UI system?
};
/////////////////////////////////////////////////////////////////////////////////////
*/

window.onload = ()=>{
	rootDob = Dob('rootDob');
	rootSplat = new Splat(null, rootDob);
	console.log('Created rootSplat='+rootSplat+' and about to make a Split and rootSplat.setSplit to display it');
	let fn = exampleFnToDisplay;
	let split = newSplitForFn_experimental(fn);
	if(options.do_forkTryMaxWidth_experimentOnWindowLoad){
		//split = split.forkTryMaxWidth(12500); //FIXME this is just a test
		//split = split.forkTryMaxWidth(1400); //FIXME this is just a test
		//split = split.forkTryMaxWidth(1800); //FIXME this is just a test
		split = split.forkTryMaxWidth(2200); //FIXME this is just a test
		//split = split.forkTryMaxWidth(400); //FIXME this is just a test
		//split = split.forkTryMaxWidth(200); //FIXME this is just a test
	}
	rootSplat.setSplit(split); //display it recursively
};


/*return {
	U: U,
	vm: vm,
	Split: Split,
	loadOpsByName: loadOpsByName,
};*/
//TODO move window out of that lambda then... })();
</script>
<script>
	
</script>
</head><body>
	Wikibinator203 widget: drag and drop tree UI for viewing and calling Wikibinator203 fns/lambdas...
	<br><br>
	Doesnt work enough yet. Use Wikibinator203DirectedGraphUI.html instead.
	<br><br>
	
	<center><div id=rootDob></div></center>
	<br><font color=gray>
	DONE/FIXED: [[[]]] etc is only showing 1 []. options.displayVarargLists is probably buggy.<br>
	DONE ENOUGH: make estimateWidth more accurate by checking for isFoldL isFoldT etc, since those cause not all childs to be displayed or not displayed the normal way.<br>
	DONE, it was conflict between flex layout and rowspan andOr colspan: dobs.suffixb is displaying too low. rowspan and colspan used in same table might be confusing it??<br>
	DONE enough, but still some vertical padding to get rid of: do_forkTryMaxWidth_experimentOnWindowLoad make some be isOneLine and some not depending on estimateWidth(true) recursively, to make good use of screen space.<br>
	DONE: forkTryMaxWidth, add estimateWidth and estimateHeight funcs to Split.prototype (added those already but theres throw todo in it), for use with isOneLine, so it doesnt get too long, and use it recursively.<br>
	CANCELLED cuz dont need to reparent dobs when using flex layout: addDolayoutFuncToWikibTreeUINodesAndSeparateLayoutDobsFromSelfDobsWhichGetReparentedInLayoutNodesAndOnlyCreateLayoutNodesIfNotAlreadyExist<br>
	DONE: eachFirstLineCanHaveMultiThingsInIt, an isOneLine syntax/layout for the first n params in a {} [] () but after that each thing is on its own line,
	cuz it has to be that way to be 2 child rectangles in each rectangle, (but later can do it without "2 child rectangles in each rectangle" and vararg number of childs per rectangle).
	This will need to at least estimate the horizontal size of the first n things, to choose n to display that way to not be wider than the window, considering how far its already tabbed over.<br>
	</font>
	<br>
	TODO keyboard left right down buttons navigate split tree, and show which is selected.<br>
	TODO Whichever split/splat is selected, have a few fast ways to insert, remove, etc from it, as code editor, but only allow changes that leave splat.fn.n.curriesLeft() (is that the right func?) being at least 1 aka CAN ONLY EDIT THE CODE IN WAYS THAT DONT CAUSE IT TO EVAL YET. Cuz there will be a separate way in UI to eval things so you dont do it by accident.<br>
	TODO given that the code editor (by selection in the tree) wont let you cause eval, make a separate way of using UI to do evals, maybe similar to iotavm/iotadesktop (an experiment on my github) where you grab a lambda with mouse, drag it to another lambda, which calls it and you are then dragging (holding with mouse) what that lambda call returned and can keep dragging.<br>
	TODO open/close branch<br>
	TODO <> for canvas literals etc.<br>
	TODO canvas or img src= changing the image each time (canvas literals in code)<br>
	TODO webAudioAPI<br>
	TODO gamepads<br>
	TODO drag and drop to call lambda on lambda to find/create lambdas, including between multiple widgets and across different webpages using the 256 bit ids to copy all reachable lambdas not copied so far<br>
	TODO checkboxes to change displayVarargS etc so users can see what is being hidden to make it more intuitive, even though whats hidden can be derived from contents of the prefix and suffix dobs, other than isLiteral displaying as canvas or webAudioAPI etc cuz that could be hard to see exact pixel brightness etc, or splate.isOpen being false.<br>
	<br>
	TODO the "some kind of simple game" mentioned in other TODO, start with just canvas/pic literals, not moving, made by drag and drop lambda onto lambda to find/create lambda that is or contains such graphics. When it starts to look like a screenshot of a game, then mark this as done and move on to the other TODO which is to make it move and playable by gamepad etc.<br>
	<br>
	TODO some kind of simple game, pacman-like or tetris-like etc, make that game by using the tree UI then play it with gamepad. Record a video of the whole thing and put up website where ppl can do that same thing or variants of it, with lambdas in general, but website wont store what they make yet as the p2p network isnt built yet.<br>
	<br>
	DO THIS LATER, GET eachFirstLineCanHaveMultiThingsInIt working first: TODO use flex laying or inline or something (see css) to do word-wrap but for rectangles<br>
	<br>
	
	<input type=button onclick="rootSplat.putThisStringInAllEmptyDobsDeep('.');" value="show all dobs put . in them if empty":></input>
	
	
	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	LICENSE AT TIME 2022-9-9 IS THIS BUT TODO COPY CHANGED LICENSE (BEFORE FINALIZING IT SOMEDAY) FROM LICENSE FILE WHEN CHANGED:[[[
Ben F Rayfield offers the wikibinator203 VM prototype, UI, and various tools, under this license
<br><br>
I (Ben F Rayfield) know this license is a mess and am planning to rewrite it to be much smaller,
divided into small paragraphs, move some parts to tutorials or other documents about the software,
and only keep the parts that arent strongly implied by the other parts.
Now that I've written about the "infinite size unweighted directed-graph with 3 edge-colors",
that seems an easier way to explain why it would cause problems for
specific people to own specific nodes and edges in that directed-graph,
and that nodes could be dangerous if copied into executable files outside the system, etc.
<br><br>
This license contains the 3 paragraphs of the MIT license and some extra copyleft stuff.
<br><br>
This is experimental software.
<br><br>
[THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.] (COPIED FROM LAST PARAGRAPH OF MIT LICENSE, APPLIES HERE)
<br><br>
It may be illegal in some countries to say certain things,
such as "the holocaust didnt happen" for example.
This license protects free speech in evilbit=true namespace
by making it normal that anything said there is not claiming it is true,
as lambdas generate many variants of things that are true and many false,
so it would be negligence to believe something there just because you read it,
and all it means is that its a piece of data, not that its true or false.
If you put such data there and say with your mouth its true,
that thing your mouth did may be claiming "the holocaust didnt happen",
but that string "the holocaust didnt happen",
along with "the holocaust is made of green cheese" etc are just data
and are not legal claims. Numbers by themself do not have legal effect.
<br><br>
This software uses a constant infinite size unweighted directed-graph
with 3 edge-colors, that contains all possible patterns of finite
amount of information that take finite amount of compute time and memory,
which an infinite number of subsets of it (if not the whole thing?)
are already near optimally compressed (near lowest kolmogorov complexity)
in its natural form. These edges are Func, Param, and EvalsTo,
where Func called on Param returns EvalsTo. Nobody owns that directed-graph
nor any nodes or edges in it,
nor the using of it as lambdas/wikibs (nodes are lambdas/wikibs).
Nobody owns wikibs. They are shared facts of maths many people and software
can use together. A wikib is a kind of number, stateless and immutable
(or approximations of it in some ways of using it)
universal lambda function, combinator, pattern-calculus function, fact of math,
a pure function, and a data structure that is defined completely as a forest
node with 2 child wikibs down to leaf (leaf also has 2 childs (identity
function and leaf)). Leaf (aka U aka Wikibinator203) is the universal
function, from which all turing-complete patterns of finite amount of
information can be built, used, and shared. Forall wikib x, forall wikib y,
x called on y is a wikib, which may be halted or evaling (to a halted wikib
or never halts). Every wikib is a derivative-work of leaf, which can be
proven by calling leaf on itself in various combinations, to make any wikib.
While obeying this license and using a wikibinator203 VM that correctly
implements the spec, it is safe to call any wikib on any wikib since all
it does is find or create wikibs, but if its used to control external
systems (such as robots, buying and selling things, or telling people
what to believe or what to do outside a simulated world, or copying a
wikib to a new file, renaming that file x.exe, then double-clicking that
file), it is entirely the responsibility of who hooks it to those systems
to verify its safe, such as by math proofs, networks of digital signatures,
or other evidence, especially considering that it can create all possible
computer viruses and ransomware and other evil things (safely in a
sandbox across 1 or many computers) and good things, and that in 1 of
its 2 namespaces (evilbit=true), it is an antivirus quarantine and
uncensored area, a sandbox across whichever computers opt into using
this data structure together, where all possible wikibs are allowed.
In the antivirus quarantine, you may share viruses like posts in a
social network, turing-complete messages that others may, for example,
say ["this is a virus" TheVirus] or use the virus in a meme-like piece
of art (such as a satirical work making fun of viruses could literally
contain such viruses) and do experiments, make games, musical
instruments, tools, or anything of pure information. It would be very
destructive to the system if there is any possible math statement which
is not allowed, such as removing a virus or other "evil" wikibs while
it has incoming pointers. It would be destructive to the wikib systems,
because halting-oracles have been proven impossible, and a halting-oracle
would be needed to determine if a certain wikib would generate, or would
not generate, a certain other wikib, without waiting up to an infinite
time to observe what it does (by the universal lambda math). The other
namespace (evilbit=false) works like the normal internet, if those who
opt in can find a way to do that without breaking the wikib math so much
its unusable, a way to claim a certain wikib is safe, unlike in
evilbit=true where there is no reasonable expectation that it is safe
to give those wikibs execute permission, or to believe any information
in them, or to obey anything they might tell you to do with a message
on the screen. It would be negligence for someone to give execute
permission to, believe, or obey, anything in an antivirus quarantine
(which many apps may run inside across many computers) if that causes
a problem, and similarly for the evilbit=false area, since saying its
evilbit=true or evilbit=false (which happens in the first byte of a
256 bit id for example) is just a word that people or computers can
say about a wikib, that they believe it to be safe or not.
If in doubt, use evilbit=true aka antivirus quarantine.
The 256 (or 512) bit ids can safely be shared in public as #hashtags.
The sending and receiving of this data structure across a network
does not count that network as an "external system"
and is part of the sandbox. Similarly, a Human just using the
facts of math together with other Humans and AIs, is part of the sandbox,
as a wikib can exist inside a Human mind (which is turing-complete),
but believing or obeying it in the Human mind is outside the sandbox.
A wikib being a "fact of math" is inside the sandbox,
and can derive its own ids which are similar to godel-numbers,
and in the pure deterministic (not "approximations") way of using it,
it can not lie about anything inside the sandbox,
but if its viewed as statements about outside the sandbox those can be lies.
For example, the wikib "this sentence is false", and "two plus two equals five",
are both true, since those are just utf8 bytes, and it is true that
they do not break any rules of the universal lambda,
but if you view them as statements about natural-language
then that refers to patterns of thoughts outside the sandbox.
If instead you derive numbers and use the Ax opcode to prove
a function called on a param gives a certain return value,
then it will not halt if you try to eval either of those in pure math form.
All halted wikibs are true. All wikibs which will never halt are false.
Approximations of wikibs can guarantee halting by recursively limiting
compute time and memory etc, so in theory there should be some way
to safely use it to operate time critical dangerous processes
in the evilbit=true area, but due to the evilbit=false area
"throwing a wrench into the machine" by removing pieces of math
based on Human opinions etc, the antivirus quarantine is safest.
The antivirus quarantine, in the way its the math that the code is based on,
has already whitelisted an infinite set,
(of all of a certain kind of universal function, by calling it on itself in various combos)
unlike the common practice of blacklisting "evil" things as they are
observed or predicted over time. The only thing the antivirus quarantine blacklists
is mutable state. A pure function can not infect a harddrive or RAM etc,
since it can not call thePureFunction(mutableState)->next_mutableState,
except to store cached function calls (including wrapping tiny and bigdata size bitstrings).
A virus is only dangerous if it can modify some mutable state.
This is a formal-verification system. This is also a low-latency number-crunching turing-complete system.
For example, this system's turing-complete-type-system can have a linked-list of lambdas
that when called on [church-pair of themself and themself] evals to one of the representations of the exact value of pi,
and if you tried to insert into that linked-list a value not matching that, it would never halt,
and if you tried to insert, in parallel a million values matching that,
you would in each of those million wikib_called_on_wikib get a linked-list with 1 more thing in it.
<br><br>
If there is any conflict between the above "Nobody owns wikibs" paragraph and the below 2 paragraphs copied from MIT license,
then that "Nobody owns wikibs" paragraph wins, overpowers the legal effects, of the 2 paragraphs below,
and if that is not legally possible to do then it is not legally possible to use this software at all.
<br><br>
Except for the "Nobody owns wikibs" paragraph above, which in a copyleft way applies to every wikibinator203 VM,
permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
<br><br>
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
]]]

	
</body></html>
